namespace Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.OrderUpdates
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
	using System.Reflection;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.ChangeTracking;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Configuration;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.History;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Integrations.Plasma;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Service;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Service.ResourceAssignment;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks.OrderTasks;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks.ServiceTasks;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Utilities;
    using Skyline.DataMiner.Library;
    using Skyline.DataMiner.Net.ResourceManager.Objects;

    public class OrderAddOrUpdateHandler : OrderUpdateHandler
    {
        private readonly List<FunctionInfo> functionInfosBeforeDeterminingOrderDefinition = new List<FunctionInfo>();

        public OrderAddOrUpdateHandler(Helpers helpers, Order order, OrderUpdateHandlerInput input) : base(helpers, order, input)
        {
        }

        protected override void CollectActionsToExecute()
        {
            actionsToExecute.Add(GetExistingOrderAndEvent);
            actionsToExecute.Add(RemoveRunningPreliminaryStartNowOrder);

            if (!order.IsSaved && !options.HasFlag(OptionFlags.SkipDetermineOrderDefinition))
            {
                actionsToExecute.Add(UpdateAutoGeneratedServiceTimings);

                // 5 extra steps to determine full order definition
                actionsToExecute.Add(RegisterCurrentFunctions);
                actionsToExecute.Add(GenerateProcessingServices);
                actionsToExecute.Add(AssignResourcesToServices);
                actionsToExecute.Add(GenerateVizremConverterServices);
                actionsToExecute.Add(GenerateRoutingServices);

                actionsToExecute.Add(PostRoutingGenerationChecks);

                actionsToExecute.Add(ResetFunctions);

                actionsToExecute.Add(CheckMajorTimeslotChange);
            }

            actionsToExecute.Add(DetermineRestOfTheFlow);
            return; // no more actions should be executed past this, if necessary add actions to the subhandlers
        }

        private void DetermineRestOfTheFlow()
		{
            OrderUpdateHandler orderUpdateHandler;

			if (order.ShouldBeRunning && order.Change.Summary is OrderChangeSummary orderChangeSummary && orderChangeSummary.ServicesWereAdded && !orderChangeSummary.SavedOrderIsBeingBooked)
			{
                Log(nameof(DetermineRestOfTheFlow), $"Detected added services for running order");

                orderUpdateHandler = new AddServicesToRunningOrderSubHandler(Helpers, order, new OrderUpdateHandlerInput { IsHighPriority = isHighPriority, Options = options, ProcessChronologically = processChronologically }, existingOrder);      
			}
			else
			{
                orderUpdateHandler = new OrderAddOrUpdateSubHandler(Helpers, order, new OrderUpdateHandlerInput { IsHighPriority = isHighPriority, Options = options, ProcessChronologically = processChronologically }, existingOrder);
            }

            var result = orderUpdateHandler.Execute();

            tasks.AddRange(result.Tasks);
            Exceptions.AddRange(result.Exceptions);
        }

		private void RegisterCurrentFunctions()
        {
            Report("Building service chain ...");

            foreach (var service in order.AllServices)
            {
                foreach (var function in service.Functions)
                {
                    var functionInfo = new FunctionInfo(service.Name, function);

                    functionInfosBeforeDeterminingOrderDefinition.Add(functionInfo);

                    Log(nameof(RegisterCurrentFunctions), $"Registered FunctionInfo: {functionInfo}");
                }
            }
        }

        private void ResetFunctions()
        {
            foreach (var service in order.AllServices)
            {
                foreach (var function in service.Functions)
                {
                    var functionInfo = functionInfosBeforeDeterminingOrderDefinition.SingleOrDefault(r => r.ServiceName == service.Name && r.FunctionLabel == function.Definition.Label);

                    function.Resource = functionInfo?.Resource;

                    bool serviceHasBeenGeneratedToDetermineOrderDefinition = functionInfo == null;
                    if (serviceHasBeenGeneratedToDetermineOrderDefinition) continue;

                    foreach (var parameter in function.Parameters.Concat(function.InterfaceParameters))
                    {
                        parameter.Value = functionInfo.ProfileParameterValues.ContainsKey(parameter.Id) ? functionInfo.ProfileParameterValues[parameter.Id] : null;
                    }

                    Log(nameof(ResetFunctions), $"Reset FunctionInfo: {functionInfo}");
                }
            }
        }

        private void PostRoutingGenerationChecks()
		{
			if (order.IntegrationType == Utils.YLE.Integrations.IntegrationType.Plasma)
			{
                // status for plasma orders can only be fully set when we have routing information

                PlasmaIntegration.UpdateOrderStatus(Helpers, order);
			}

			// Setting short description to have correct order history UI
			foreach (var service in order.AllServices)
			{
				service.GetShortDescription(order);
			}
		}

        /// <summary>
        /// This checks if the updated service timespans are outside of the existing order timespan.
        /// If this is the case, the existing service resources that are outside of the order are disconnected and their timing is updated.
        /// If needed, they are added again when assigning the contributing resources to the order.
        /// This was introduced as the UpdateOrderReservation step would fail if the contributing resources are not available in the new timeslot.
        /// </summary>
        private void CheckMajorTimeslotChange()
        {
            if (isNewOrder) return;

            MajorTimeslotChange majorTimeslotChange = new MajorTimeslotChange(Helpers, existingOrder);
            var serviceResourceUsageDefinitions = existingOrder.Reservation.ResourcesInReservationInstance.OfType<ServiceResourceUsageDefinition>().ToList();
            foreach (var existingService in existingOrder.AllServices)
            {
                Log(nameof(CheckMajorTimeslotChange), $"Checking Service {existingService.Name}, IsBooked {existingService.IsBooked}, Node ID: {existingService.NodeId}");
                Log(nameof(CheckMajorTimeslotChange), $"Existing Service Timing: {existingService.Start.ToFullDetailString()} - {existingService.End.ToFullDetailString()}");
                Log(nameof(CheckMajorTimeslotChange), $"Order Timing: {order.Start.ToFullDetailString()} - {order.End.ToFullDetailString()}");

                if (!MajorTimeslotChange.ServiceRequiresMajorTimeslotChange(order, existingService))
                {
                    Log(nameof(CheckMajorTimeslotChange), $"No major time slot change required for service {existingService.Name}");
                    continue;
                }

                var serviceResourceUsageDefinition = serviceResourceUsageDefinitions.FirstOrDefault(x => x.ServiceDefinitionNodeID == existingService.NodeId);
                if (serviceResourceUsageDefinition == null)
                {
                    // Resource was not assigned to order - no need to release it and update its timing
                    Log(nameof(CheckMajorTimeslotChange), "No need to update service timings as it is not assigned as contributing resource to the order reservation");
                    continue;
                }

                majorTimeslotChange.RegisterServiceToRelease(existingService);

                // Timing update is only required for services that are still part of the order
                var updatedService = order.AllServices.FirstOrDefault(x => x.Name.Equals(existingService.Name));
                if (updatedService == null) continue;

                majorTimeslotChange.RegisterServiceTimingChange(updatedService, existingService);

                // Check what functions need to change resource
                var functionsThatRequireResourceChanges = GetFunctionsThatRequireResourceChanges(updatedService);

                majorTimeslotChange.RegisterResourcesToRelease(updatedService, functionsThatRequireResourceChanges);
                majorTimeslotChange.RegisterResourcesToUpdate(updatedService, functionsThatRequireResourceChanges.Where(x => x.Resource != null));

                //Flag for EVS recording major timeslot update
                majorTimeslotChange.RegisterMajorTimeslotChange(updatedService);
            }

            try
            {
                majorTimeslotChange.Execute(tasks);
            }
            catch (Exception e)
            {
                Log(nameof(CheckMajorTimeslotChange), $"Unable to update service timing: {e}");
            }
        }

        private List<Function.Function> GetFunctionsThatRequireResourceChanges(Service service)
        {
            List<Function.Function> functionsThatNeedToChangeResource = new List<Function.Function>();

            var availableResources = service.GetAvailableResourcesPerFunctionBasedOnTiming(Helpers);

            foreach (var function in service.Functions)
            {
                if (function.Resource is null)
                {
                    Log(nameof(GetFunctionsThatRequireResourceChanges), $"Service {service.Name} function {function.Definition.Label} resource is null, no change or release required");
                }
                else if (availableResources[function.Definition.Label].Contains(function.Resource))
                {
                    Log(nameof(GetFunctionsThatRequireResourceChanges), $"Service {service.Name} function {function.Definition.Label} resource {function.Resource} is still available from {service.StartWithPreRoll.ToString("O")} to {service.EndWithPostRoll.ToString("O")}, no change or release required");
                }
                else
                {
                    Log(nameof(GetFunctionsThatRequireResourceChanges), $"Service {service.Name} function {function.Definition.Label} resource {function.Resource} is NOT available anymore from {service.StartWithPreRoll.ToString("O")} to {service.EndWithPostRoll.ToString("O")}, change or release required");
                    function.Resource = null;
                    functionsThatNeedToChangeResource.Add(function);
                }
            }

            return functionsThatNeedToChangeResource;
        }

        /// <summary>
        /// This class is used to perform certain actions needed when moving an order to a new, non-overlapping timeslot.
        /// </summary>
        private sealed class MajorTimeslotChange
        {
            private readonly Helpers helpers;
            private readonly Order existingOrder;

            private readonly List<Service> servicesToRelease = new List<Service>();
            private readonly List<ChangeServiceTimeTask> changeServiceTimeTasks = new List<ChangeServiceTimeTask>();
            private readonly List<SetMajorTimeslotFlagTask> majorTimeslotChangeTasks = new List<SetMajorTimeslotFlagTask>();
            private readonly List<ReleaseResourcesTask> releaseResourceTasks = new List<ReleaseResourcesTask>();
            private readonly List<UpdateResourcesTask> resourceUpdateTasks = new List<UpdateResourcesTask>();

            public MajorTimeslotChange(Helpers helpers, Order order)
            {
                this.helpers = helpers;
                this.existingOrder = order;
            }

            /// <summary>
            /// This method will register a service for which the contributing resource will be released from the order reservation.
            /// </summary>
            /// <param name="service">Service for which the resource should be removed from the order.</param>
            public void RegisterServiceToRelease(Service service)
            {
                servicesToRelease.Add(service);
            }

			/// <summary>
			/// This method will register a service that requires a change in timing.
			/// </summary>
			/// <param name="service">Service that requires a change in its timing.</param>
			/// <param name="oldService"></param>
			public void RegisterServiceTimingChange(Service service, Service oldService = null)
            {
                changeServiceTimeTasks.Add(new ChangeServiceTimeTask(helpers, service, oldService));
            }

            /// <summary>
            /// This method will register a service that requires a major timeslot change.
            /// </summary>
            /// <param name="service">Service that requires a major timeslot change.</param>
            public void RegisterMajorTimeslotChange(Service service)
            {
                majorTimeslotChangeTasks.Add(new SetMajorTimeslotFlagTask(helpers, service));
            }

            /// <summary>
            /// This method will register a service and some or all of its functions to release their resources.
            /// All functions will have their resources released regardless of the value of its Resource property.
            /// </summary>
            /// <param name="service">Service for which the resources of certain functions should be released.</param>
            /// <param name="functionsToRelease">Functions of which the resources should be released.</param>
            public void RegisterResourcesToRelease(Service service, IEnumerable<Function.Function> functionsToRelease)
            {
                if (!functionsToRelease.Any()) return;
                releaseResourceTasks.Add(new ReleaseResourcesTask(helpers, service, functionsToRelease.ToList()));
            }

            /// <summary>
            /// This method will register a service and all or some of its functions to require resource changes.
            /// The resource defined in the Resource property of the function will be used to assign to the function.
            /// </summary>
            /// <param name="service">Service for which the resources of certain functions should be updated.</param>
            /// <param name="functionsToUpdate">Functions of which the resources should be updated.</param>
            public void RegisterResourcesToUpdate(Service service, IEnumerable<Function.Function> functionsToUpdate)
            {
                if (!functionsToUpdate.Any()) return;
                resourceUpdateTasks.Add(new UpdateResourcesTask(helpers, service, functionsToUpdate.ToList()));
            }

            /// <summary>
            /// Executes a list of tasks that have been defined by registering certain actions.
            /// 1. Release Contributing Resources from the Order
            ///		(A parent booking with unlocked contributings cannot be moved to a new timeslot in which they are not available)
            /// 2. Release Resources from the Functions of the Service reservations that require it
            ///		(Moving a reservation with resources assigned to it could go to quarantined state if the assigned resource is not available anymore in the new timeslot)
            /// 3. Move the Contributing reservations to the new timeslot
            ///		(To make sure that they are available in the new order timeslot)
            /// 4. Reassign alternative, available Resources to the functions of the Contributing services
            ///		- Existing resource assignments that are valid in the new timeslot will not change
            ///		- If the existing resource assignment is not valid in the new timeslot and an alternative resource is available, assign that one instead
            ///		- If the existing resource assignment is not valid in the new timeslot and no alternative resource is available, don't assign another one
            /// </summary>
            /// <param name="tasks">General list of tasks that have been executed by the OrderUpdateHandler.</param>
            public void Execute(List<Task> tasks)
            {
                // Release contributing services
                if (servicesToRelease.Any())
                {
                    ReleaseContributingServiceFromOrderTask releaseContributingServiceFromOrderTask = new ReleaseContributingServiceFromOrderTask(helpers, existingOrder, servicesToRelease);
                    tasks.Add(releaseContributingServiceFromOrderTask);
                    if (!releaseContributingServiceFromOrderTask.Execute()) helpers.Log(nameof(OrderUpdateHandler), nameof(CheckMajorTimeslotChange), $"{releaseContributingServiceFromOrderTask.Description} failed");
                }

                // Release resources from service functions that are not available in the new timeslot
                foreach (var releaseResourceTask in releaseResourceTasks)
                {
                    tasks.Add(releaseResourceTask);
                    if (!releaseResourceTask.Execute()) helpers.Log(nameof(OrderUpdateHandler), nameof(CheckMajorTimeslotChange), $"{releaseResourceTask.Description} failed");
                }

                // Move services to new timeslot
                foreach (var changeTimingTask in changeServiceTimeTasks)
                {
                    tasks.Add(changeTimingTask);
                    if (!changeTimingTask.Execute()) helpers.Log(nameof(OrderUpdateHandler), nameof(CheckMajorTimeslotChange), $"{changeTimingTask.Description} failed");
                }

                // Set flag for major timeslot change
                foreach (var setMajorTimeslotFlagTask in majorTimeslotChangeTasks)
                {
                    tasks.Add(setMajorTimeslotFlagTask);
                    if (!setMajorTimeslotFlagTask.Execute()) helpers.Log(nameof(OrderUpdateHandler), nameof(CheckMajorTimeslotChange), $"{setMajorTimeslotFlagTask.Description} failed");
                }

                // Assign available resources to service functions
                foreach (var resourceUpdateTask in resourceUpdateTasks)
                {
                    tasks.Add(resourceUpdateTask);
                    if (!resourceUpdateTask.Execute()) helpers.Log(nameof(OrderUpdateHandler), nameof(CheckMajorTimeslotChange), $"{resourceUpdateTask.Description} failed");
                }

                // Re-assigning contributing services is done during the AddOrUpdateOrderReservation step
            }

            /// <summary>
            /// Checks if a major timeslot change is required to move the existing services to the new timeslot dictated by the order timing.
            /// </summary>
            /// <param name="updatedOrder">Order object with the new timslot.</param>
            /// <param name="existingService">Service object as retrieved from SRM.</param>
            /// <returns>True, if the service was booked, is not an event level reception and its timing overlaps with the new order timing.</returns>
            public static bool ServiceRequiresMajorTimeslotChange(Order updatedOrder, Service existingService)
            {
                if (!existingService.IsBooked) return false;
                if (existingService.IsSharedSource) return false;

                // No timing changes required if the existing service timing overlaps with the updated order timing
                if (existingService.Start >= updatedOrder.Start && existingService.Start < updatedOrder.End) return false;
                if (existingService.End > updatedOrder.Start && existingService.End <= updatedOrder.End) return false;

                return true;
            }
        }
    }
}
