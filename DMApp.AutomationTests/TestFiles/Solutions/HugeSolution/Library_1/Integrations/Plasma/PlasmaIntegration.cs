namespace Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Integrations.Plasma
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.ChangeTracking;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Configuration;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Contracts;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Event;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Exceptions;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Integrations;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.OrderManagerElement;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.ServiceDefinition;
	using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Utilities;
	using Skyline.DataMiner.Net.Messages.SLDataGateway;
	using Skyline.DataMiner.Utils.YLE.Integrations;
	using Skyline.DataMiner.Utils.YLE.Integrations.Ceiton;
	using Skyline.DataMiner.Utils.YLE.Integrations.Integrations.Plasma.Enums;
	using Skyline.DataMiner.Utils.YLE.Integrations.Plasma;
	using BackupType = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.BackupType;
	using OrderStatus = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.Status;
	using Service = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Service.Service;
	using TaskStatus = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks.Status;
	using VirtualPlatform = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.ServiceDefinition.VirtualPlatform;

	/// <summary>
	/// Plasma Integration class.
	/// </summary>
	public class PlasmaIntegration : Integration
	{
		private const string MediapolisPlasmaUserCode = "mediapolis";

		public PlasmaIntegration(Helpers helpers, OrderManagerElement orderManagerElement) : base(helpers, orderManagerElement)
		{
		}

		public override IntegrationType IntegrationType => IntegrationType.Plasma;

		protected override string IntegrationText => "Automatically generated by Plasma integration.";

		private ServiceDefinition FixedLineLyServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.FixedLineLyServiceDefinitionId);
			}
		}

		private ServiceDefinition FixedLineMediapolisServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.FixedLineMediapolisServiceDefinitionId);
			}
		}

		private ServiceDefinition FixedLineAtvuServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(ServiceDefinitionGuids.FixedLineAtvuReception);
			}
		}

		private ServiceDefinition YleHelsinkiDestinationServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.YleHelsinkiDestinationServiceDefinitionId);
			}
		}

		private ServiceDefinition YleMediapolisDestinationServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.MediapolisDestinationServiceDefinitionId);
			}
		}

		private ServiceDefinition RecordingMessiLiveServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.RecordingMessiLiveServiceDefinitionId);
			}
		}

		private ServiceDefinition RecordingMessiLiveBackupServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.RecordingMessiLiveBackupServiceDefinitionId);
			}
		}

		private ServiceDefinition RecordingMessiNewsServiceDefinition
		{
			get
			{
				return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.RecordingMessiNewsServiceDefinitionId);
			}
		}

		public override void HandleUpdate(string id, string integrationData)
		{
			Log(nameof(HandleUpdate), $"Received integrationdata: {integrationData}");

			Program program = ParseProgram(integrationData);

			var existingOrder = helpers.OrderManager.GetPlasmaOrder(id, program?.PlasmaId);

			Log(nameof(HandleUpdate), $"Found {(existingOrder is null ? "no order" : $"order {existingOrder.Name}")} for {LiteOrder.PropertyNameEditorialObjectId} '{id}'");

			if (existingOrder != null)
			{
				if (existingOrder.Status == OrderStatus.Completed || existingOrder.Status == OrderStatus.CompletedWithErrors)
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.OK, "HandleUpdate|No action performed|Unable to update completed order");
					return;
				}

				if (existingOrder.IntegrationType != IntegrationType.Plasma)
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.OK, $"HandleUpdate|No action performed|Plasma shouldn't update linked {existingOrder.IntegrationType} order '{existingOrder.Name}'");
					return;
				}

				RetrieveLock(existingOrder);
			}

			bool orderShouldBeCancelled = program == null || !program.IsEligibleForOrderCreation(true, helpers);
			if (orderShouldBeCancelled)
			{
				if (existingOrder == null)
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.Removed, $"HandleUpdate|No action performed|Program is {(program is null ? "removed" : "not eligible for Order creation")}");
					return;
				}

				CancelOrder(existingOrder, id);
			}
			else
			{
				AddOrUpdateProgram(program, existingOrder, id);
			}
		}

		private Program ParseProgram(string serializedProgram)
		{
			try
			{
				return Program.Deserialize(serializedProgram);
			}
			catch (Exception e)
			{
				Log(nameof(ParseProgram), $"Unable to parse program: {e}");
				return null;
			}
		}

		private void AddOrUpdateProgram(Program program, Order existingOrder, string id)
		{
			if (!ShouldPlasmaOrderBeCreated(program, existingOrder, id)) return;

			var contract = RetrieveOpenContractDuringTransmission(program.LiveTransmission);
			if (contract == null)
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.Failed, "AddOrUpdateProgram|No action executed|No open contract during transmission");
				return;
			}

			var order = BuildOrder(program, contract, existingOrder);
			if (order == null)
			{
				return;
			}

			try
			{
				if (AddOrUpdateSrmOrder(order))
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.OK, "AddOrUpdateProgram|Action succeeded|Adding or updating order succeeded", order.Id, order.Event.Id);

					PollCeitonProjectAndProduct(program);
				}
				else
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.Failed, "AddOrUpdateProgram|Action failed|Adding or updating order failed", order.Id, order.Event.Id);
				}
			}
			catch (Exception e)
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.Failed, $"AddOrUpdateProgram|Action failed|Adding or updating order failed: {e}", order.Id);
			}
		}

		private Order BuildOrder(Program program, Contract contract, Order existingOrder)
		{
			Order order = null;
			try
			{
				order = CreateOrder(program, contract, existingOrder);

				return order;
			}
			catch (Exception e)
			{
				Log(nameof(BuildOrder), $"Exception while building order: {e}");
				SendResponseToOrderManagerElement(program.Id, UpdateStatus.Failed, $"AddOrUpdateProgram|No action executed|Building order failed: {e}", order?.Id ?? existingOrder?.Id);

				return order;
			}
		}

		private void PollCeitonProjectAndProduct(Program program)
		{
			try
			{
				// Ceiton Integration will update this Event in case of any updates
				CeitonElement ceiton = new CeitonElement(orderManagerElement.CeitonElement);
				ceiton.PollProject(program.ProjectNumber);
				ceiton.PollProduct(program.ProductNumber);
			}
			catch (Exception e)
			{
				// do not send message as we already forwarded that the plasma order itself was successfully created
				helpers.Log(nameof(PlasmaIntegration), nameof(PollCeitonProjectAndProduct), $"Exception polling ceiton project/product: {e}");
			}
		}

		private bool ShouldPlasmaOrderBeCreated(Program program, Order existingOrder, string id)
		{
			if (program == null)
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.OK, "AddOrUpdateProgram|No action required|Program does not exist");
				return false;
			}

			if (!program.IsEligibleForOrderCreation(true, helpers))
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.OK, "AddOrUpdateProgram|No action required|Program is not eligible");
				return false;
			}

			if (program.LiveTransmission.IsAreenaLiveTransmission())
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.OK, "AddOrUpdateProgram|No action required|Areena live transmission handled by Feenix");
				return false;
			}

			// Plasma updates should be ignored 30 minutes before live if the Pebble Beach integration is enabled.
			if (existingOrder != null && DateTime.Now.AddMinutes(30) > program.LiveTransmission.Start && orderManagerElement.IsPebbleBeachIntegrationEnabled)
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.OK, $"AddOrUpdateProgram|No action executed|Update was handled 30 minutes before live (start time: {program.LiveTransmission.Start}) and Pebble Beach integration is enabled. Update will be handled by Pebble Beach integration.");
				return false;
			}

			// Ignore updates 10min before live
			if (DateTime.Now.AddMinutes(10) > program.LiveTransmission.Start)
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.OK, "AddOrUpdateProgram|No action required|Live transmission ended already or will end within 1h");
				return false;
			}

			return true;
		}

		/// <summary>
		/// Remove the order for the given Plasma ID.
		/// This will only be called when the row is removed from the element.
		/// </summary>
		/// <param name="order">Order which will be canceled.</param>
		/// <param name="id">Plasma id</param>
		private void CancelOrder(Order order, string id)
		{
			try
			{
				if (order.Status == OrderStatus.Cancelled || order.Status == OrderStatus.Completed || order.Status == OrderStatus.CompletedWithErrors)
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.Removed, "CancelOrder|No action required|Order was already removed or completed");
					return;
				}

				if (CancelPlasmaOrder(order))
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.Removed, "CancelOrder|Action succeeded|Canceling order succeeded");
				}
				else
				{
					SendResponseToOrderManagerElement(id, UpdateStatus.Failed, "CancelOrder|Action failed|Canceling order failed");
				}
			}
			catch (Exception e)
			{
				SendResponseToOrderManagerElement(id, UpdateStatus.Failed, $"CancelOrder|Action failed|Canceling order failed due to: {e}");
			}
		}

		/// <summary>
		/// Updates the status of all order services to Cancelled.
		/// </summary>
		/// <returns>Boolean indicating if the update was successful or not.</returns>
		private bool CancelPlasmaOrder(Order existingOrder)
		{
			existingOrder.ReasonForCancellationOrRejection = "Plasma integration has canceled this order";
			return existingOrder.UpdateStatus(helpers, OrderStatus.Cancelled);
		}

		private Contract RetrieveOpenContractDuringTransmission(Transmission transmission)
		{
			Contract contract = null;
			var openContractsDuringTransmission = CompanyDetails.Contracts.Where(c => c.Start <= transmission.Start && c.End >= transmission.End && c.Status == ContractStatus.Open).ToList();
			if (openContractsDuringTransmission.Any())
			{
				contract = openContractsDuringTransmission.FirstOrDefault(c => c.Type == ContractType.BaseContract);
				contract = contract ?? openContractsDuringTransmission.FirstOrDefault();
			}

			return contract;
		}

		private bool AddOrUpdateSrmOrder(Order order)
		{
			try
			{
				var updateResult = order.AddOrUpdate(helpers, false);
				var tasks = updateResult.Tasks;

				foreach (var task in tasks.Where(x => x.Status == TaskStatus.Fail))
				{
					helpers.Log(nameof(PlasmaIntegration), nameof(AddOrUpdateSrmOrder), "Failed to execute task: " + task.Description);
				}

				if (tasks.Any(x => x.Status == TaskStatus.Fail && x.IsBlocking))
				{
					// Some Order creation tasks failed
					if (!RollBackTasks(tasks))
					{
						helpers.Log(nameof(PlasmaIntegration), nameof(AddOrUpdateSrmOrder), "Rollback failed");
					}

					return false;
				}

				return updateResult.UpdateWasSuccessful;
			}
			catch (Exception e)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(AddOrUpdateSrmOrder), "Something went wrong: " + e);
				return false;
			}
		}

		/// <summary>
		/// Rolls back the tasks that failed when adding or updating an order in SRM.
		/// </summary>
		/// <param name="tasks">List of tasks that were executed when adding or updating an Order in SRM.</param>
		/// <returns>True if the rollback was successful, else false.</returns>
		private static bool RollBackTasks(IEnumerable<Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks.Task> tasks)
		{
			List<Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks.Task> rollbackTasks = tasks.Where(t => t.Status == TaskStatus.Ok).Select(t => t.CreateRollbackTask()).Where(t => t != null).Reverse().ToList();

			foreach (Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks.Task rollbackTask in rollbackTasks)
			{
				if (!rollbackTask.Execute()) return false;
			}

			return true;
		}

		/// <summary>
		/// Used to create a new or update an existing Order based on the given program information and the provided contract.
		/// </summary>
		/// <param name="program">Program information as received from the Plasma Integration element.</param>
		/// <param name="contract">Base contract for YLE that is eligible during the Live Transmission.</param>
		/// <param name="existingOrder">Already existing plasma order in the system.</param>
		/// <returns>New or updated Order.</returns>
		private Order CreateOrder(Program program, Contract contract, Order existingOrder)
		{
			if (existingOrder == null)
			{
				existingOrder = CreatePlasmaOrder(program, contract);
				existingOrder.Event = CreatePlasmaEvent(program, contract);
			}
			else
			{
				helpers.AddOrderReferencesForLogging(existingOrder.Id);

				bool wasOriginalOrderSaved = existingOrder.IsSaved;
				UpdateExistingPlasmaOrder(existingOrder, program);

				if (!wasOriginalOrderSaved && existingOrder.IsSaved)
				{
					// When the fixed line source of the order was changed to a dummy service
					// Delete original order
					// Clear id and service definition for order
					// Clear id for all services
					RecreatePreliminaryOrder(existingOrder);
				}
			}

			existingOrder.SetMcrLateChangeRequired(helpers, userIsMcr: false);

			return existingOrder;
		}

		private Event CreatePlasmaEvent(Program program, Contract contract)
		{
			var plasmaEvent = helpers.EventManager.GetEvent(program.ProjectNumber);
			if (plasmaEvent == null)
			{
				return new Event(helpers)
				{
					Name = $"{program.Title.Clean()} [{program.ProjectNumber}]",
					Company = CompanyDetails.Company,
					Contract = contract.Name,
					IntegrationType = IntegrationType.Plasma,
					ProjectNumber = program.ProjectNumber,
					ProductNumbers = new[] { program.ProductNumber },
					Start = program.LiveTransmission.Start,
					End = program.LiveTransmission.End,
					Status = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Event.Status.Confirmed,
					Info = "Automatically created by Plasma integration",
					SecurityViewIds = GetSecurityViewIds(contract) // all Plasma orders should be visible for YLE
				};
			}
			else
			{
				// update product numbers
				if (!plasmaEvent.ProductNumbers.Contains(program.ProductNumber))
				{
					var productNumbers = new List<string>(plasmaEvent.ProductNumbers);
					productNumbers.Add(program.ProductNumber);
					plasmaEvent.ProductNumbers = productNumbers;
				}

				return plasmaEvent;
			}
		}

		private Order CreatePlasmaOrder(Program program, Contract contract)
		{
			var order = new Order
			{
				ManualName = String.Format("{0}[{1}]", program.Title.Clean(), program.LiveTransmission.PlasmaId),
				Start = program.LiveTransmission.Start,
				End = program.LiveTransmission.End,
				Comments = "Automatically created by Plasma Integration",
				Sources = new List<Service>(),
				IntegrationType = IntegrationType.Plasma,
				PlasmaId = program.LiveTransmission.PlasmaId,
				EditorialObjectId = program.Id,
				YleId = program.YleId,
				Type = OrderType.Video,
				Definition = new ServiceDefinition { BookingManagerElementName = SrmConfiguration.OrderBookingManagerElementName },
				Company = CompanyDetails.Company,
				Contract = contract.Name,
				CreatedByUserName = "Plasma",
				LastUpdatedBy = "Plasma",
				BillingInfo = new BillingInfo
				{
					BillableCompany = CompanyDetails.Company,
					CustomerCompany = String.Empty
				},
				PublicationStart = program.LiveTransmission.Start,
				PublicationEnd = program.LiveTransmission.End,
			};

			order.SetSecurityViewIds(GetSecurityViewIds(contract)); // All Plasma orders should be visible for whole YLE

			Log(nameof(CreatePlasmaOrder), $"Created order object with properties: {nameof(order.Start)}={order.Start.ToFullDetailString()}, {nameof(order.End)}={order.End.ToFullDetailString()}, {nameof(order.PlasmaId)}={order.PlasmaId}, {nameof(order.YleId)}={order.YleId}, {nameof(order.SecurityViewIds)}={string.Join(";", order.SecurityViewIds)}");

			// Source service
			Service sourceService = GenerateSourceService(program);
			order.Sources.Add(sourceService);
			order.Status = sourceService.IsDummy ? OrderStatus.Preliminary : OrderStatus.Confirmed;
			sourceService.AcceptChanges();

			// Destination service
			Service destinationService = GenerateDestinationService(program, order);
			sourceService.Children.Add(destinationService);
			destinationService.AcceptChanges();

			// Recording services
			var standardTvRecordingService = GenerateStandardTvRecordingService(program) ?? throw new ServiceGenerationFailedException("Generating standard tv recording failed");
			standardTvRecordingService.RecordingConfiguration.NameOfServiceToRecord = destinationService.Name;
			standardTvRecordingService.RecordingConfiguration.PlasmaIdForArchive = order.PlasmaId;
			standardTvRecordingService.RecordingConfiguration.RecordingName = order.Name;
			destinationService.Children.Add(standardTvRecordingService);
			standardTvRecordingService.AcceptChanges();

			var standardTvRecordingBackupService = GenerateStandardTvRecordingBackupService(program) ?? throw new ServiceGenerationFailedException("Generating standard tv recording backup failed");
			standardTvRecordingBackupService.RecordingConfiguration.NameOfServiceToRecord = destinationService.Name;
			standardTvRecordingBackupService.RecordingConfiguration.PlasmaIdForArchive = order.PlasmaId;
			standardTvRecordingBackupService.RecordingConfiguration.RecordingName = order.Name;
			destinationService.Children.Add(standardTvRecordingBackupService);
			standardTvRecordingBackupService.AcceptChanges();

			var newsRecordingServices = GenerateNewsRecordingServices(program);
			foreach (var newsRecordingService in newsRecordingServices.Values)
			{
				newsRecordingService.RecordingConfiguration.NameOfServiceToRecord = sourceService.Name;
				newsRecordingService.RecordingConfiguration.RecordingName = order.Name;
				sourceService.Children.Add(newsRecordingService);
				newsRecordingService.AcceptChanges();
			}

			return order;
		}

		private HashSet<int> GetSecurityViewIds(Contract contract)
		{
			var viewIds = new HashSet<int>
			{
				// All orders should be visible to MCR users
				CompanyDetails.McrSecurityViewId,

				// All orders should be visible to YLE users
				CompanyDetails.SecurityViewId
			};

			// If the company has linked orders, the orders should be visible to them as well
			foreach (Company linkedCompany in contract.LinkedCompanies)
			{
				viewIds.Add(linkedCompany.SecurityViewId);
			}

			return viewIds;
		}

		private bool IsSpecificSource(Program program, out string plasmaUserCodeValue)
		{
			plasmaUserCodeValue = null;

			var plasmaUserCodeProfileParameter = helpers.ProfileManager.GetProfileParameter(SrmConfiguration.PlasmaUserCodeProfileParameterName) ?? throw new ProfileParameterNotFoundException(SrmConfiguration.PlasmaUserCodeProfileParameterName);
			string[] specificSources = plasmaUserCodeProfileParameter.Discreets.Select(x => x.InternalValue).Except(new[] { MediapolisPlasmaUserCode }).ToArray();

			bool foundMatch = false;
			foreach (var specificSource in specificSources.Where(specificSource => program.LiveTransmission.Source.Trim().Equals(specificSource, StringComparison.InvariantCultureIgnoreCase)))
			{
				plasmaUserCodeValue = specificSource;
				foundMatch = true;
			}

			Log(nameof(IsSpecificSource), $"Source '{program.LiveTransmission.Source.Trim()}' {(foundMatch ? "equals" : "does not equal")} one or more of {string.Join(", ", specificSources)}");

			return foundMatch;
		}

		private bool IsMediapolisSource(Program program)
		{
			bool isMatch = program.LiveTransmission.Source.Trim().Equals(MediapolisPlasmaUserCode, StringComparison.InvariantCultureIgnoreCase);

			Log(nameof(IsMediapolisSource), $"Source '{program.LiveTransmission.Source.Trim()}' {(isMatch ? "equals" : "does not equal")} {MediapolisPlasmaUserCode}");

			return isMatch;
		}

		private bool IsAtvuSource(Program program)
		{
			bool isMatch = program.LiveTransmission.Source.Trim().Equals("ATVU", StringComparison.InvariantCultureIgnoreCase);

			Log(nameof(IsAtvuSource), $"Source '{program.LiveTransmission.Source.Trim()}' {(isMatch ? "equals" : "does not equal")} ATVU");

			return isMatch;
		}

		private Service GenerateSourceService(Program program)
		{
			string plasmaUserCodeValue;
			bool isSpecificSource = IsSpecificSource(program, out plasmaUserCodeValue);
			bool isMediapolisSource = IsMediapolisSource(program);
			bool isAtvuSource = IsAtvuSource(program);

			Service sourceService;

			if (isSpecificSource)
			{
				Log(nameof(GenerateSourceService), "Generating Fixed Line LY Reception");
				sourceService = GenerateFixedLineLyReceptionService(program, plasmaUserCodeValue) ?? throw new ServiceGenerationFailedException("Generating Fixed Line RX YLE Helsinki Source failed");
			}
			else if (isMediapolisSource)
			{
				Log(nameof(GenerateSourceService), "Generating Fixed Line Mediapolis Reception");
				sourceService = GenerateFixedLineMediapolisReceptionService(program) ?? throw new ServiceGenerationFailedException("Generating Fixed Line RX YLE Mediapolis Source failed");
			}
			else if (isAtvuSource)
			{
				Log(nameof(GenerateSourceService), "Generating Fixed Line ATVU Reception");
				sourceService = GenerateFixedLineAtvuReceptionService(program) ?? throw new ServiceGenerationFailedException("Generating Fixed Line RX ATVU Source failed");
			}
			else
			{
				Log(nameof(GenerateSourceService), "Generating Dummy Reception");
				sourceService = GenerateDummySourceService(program.LiveTransmission) ?? throw new ServiceGenerationFailedException("Generating Dummy Source failed");
			}

			Log(nameof(GenerateSourceService), $"Generated source service object: {sourceService.GetConfiguration().Serialize()}");

			return sourceService;
		}

		private Service GenerateDestinationService(Program program, Order linkedOrder)
		{
			bool isMediapolisSource = IsMediapolisSource(program);

			Service destinationService;

			if (isMediapolisSource)
			{
				Log(nameof(GenerateDestinationService), "Generating Mediapolis Destination");
				destinationService = GenerateYleMediapolisDestinationService(program) ?? throw new ServiceGenerationFailedException("Generating YLE Mediapolis Destination failed");
			}
			else
			{
				Log(nameof(GenerateDestinationService), "Generating YLE Helsinki Destination");

				var sourceService = linkedOrder.Sources.First(x => x.BackupType == BackupType.None);
				destinationService = GenerateYleHelsinkiDestinationService(program, sourceService) ?? throw new ServiceGenerationFailedException("Generating YLE Helsinki Destination failed");
			}

			Log(nameof(GenerateSourceService), $"Generated destination service object: {destinationService.GetConfiguration().Serialize()}");

			return destinationService;
		}

		private void UpdateExistingPlasmaOrder(Order existingOrder, Program program)
		{
			if (existingOrder is null) throw new ArgumentNullException(nameof(existingOrder));
			if (existingOrder.Event is null) throw new ArgumentException("Event property of order is null", nameof(existingOrder));
			if (program is null) throw new ArgumentNullException(nameof(program));

			existingOrder.AcceptChanges();

			Service newSourceService = GenerateSourceService(program);
			newSourceService.AcceptChanges();
			UpdateSourceService(existingOrder, newSourceService);

			Service newDestinationService = GenerateDestinationService(program, existingOrder);
			newDestinationService.AcceptChanges();
			UpdateDestinationService(existingOrder, newDestinationService);

			Service newStandardTvRecordingService = GenerateStandardTvRecordingService(program);
			newStandardTvRecordingService.AcceptChanges();
			UpdateStandardTvRecordingService(program, existingOrder, newStandardTvRecordingService);

			Service newStandardTvRecordingBackupService = GenerateStandardTvRecordingBackupService(program);
			newStandardTvRecordingBackupService.AcceptChanges();
			UpdateStandardTvRecordingBackupService(program, existingOrder, newStandardTvRecordingBackupService);

			var newNewsRecordingServices = GenerateNewsRecordingServices(program);
			foreach (var newNewsRecordingService in newNewsRecordingServices.Values)
			{
				newNewsRecordingService.AcceptChanges();
				UpdateNewsRecordingService(program, existingOrder, newNewsRecordingService);
			}

			RemoveUnusedPlasmaNewsRecordings(existingOrder, newNewsRecordingServices);

			UpdateNonPlasmaServices(existingOrder, program);

			// update event product numbers
			if (!existingOrder.Event.ProductNumbers.Contains(program.ProductNumber))
			{
				var productNumbers = new List<string>(existingOrder.Event.ProductNumbers);
				productNumbers.Add(program.ProductNumber);

				existingOrder.Event.ProductNumbers = productNumbers;
			}

			// Update name
			existingOrder.ManualName = String.Format("{0}[{1}]", program.Title.Clean(), program.LiveTransmission.PlasmaId);

			// Update last updated by
			existingOrder.LastUpdatedBy = "Plasma";

			existingOrder.PublicationStart = program.LiveTransmission.Start;
			existingOrder.PublicationEnd = program.LiveTransmission.End;

			// update order timing
			existingOrder.Start = existingOrder.AllServices.Where(x => !x.IsSharedSource).Select(x => x.Start).Min();
			existingOrder.End = existingOrder.AllServices.Where(x => !x.IsSharedSource).Select(x => x.End).Max();

			// Update editorial object id
			if (String.IsNullOrWhiteSpace(existingOrder.EditorialObjectId))
			{
				Log(nameof(UpdateExistingPlasmaOrder), $"Updating EO id to {program.Id}");
				existingOrder.EditorialObjectId = program.Id;
			}


			UpdateOrderStatus(helpers, existingOrder);
		}

		/// <summary>
		/// If an existing plasma news recording isn't used anymore among current plasma order based on feed type then it can be removed.
		/// When plasma order is switching from News to Non - News case for example, all plasma news recordings should be removed.
		/// </summary>
		/// <param name="order">Order which contains all services.</param>
		/// <param name="newNewsRecordingServices">Newly created news recordings sorted on feed type.</param>
		private void RemoveUnusedPlasmaNewsRecordings(Order order, Dictionary<NewsRecordingType, Service> newNewsRecordingServices)
		{
			var newsPlasmaRecordingsToRemove = new List<Service>();

			foreach (var existingMessiNewsRecording in order.AllServices.Where(x => x.Definition.Equals(RecordingMessiNewsServiceDefinition) && x.IntegrationType == IntegrationType.Plasma))
			{
				var newsRecordingType = GetNewsRecordingTypeFromMessiNewsRecordingService(existingMessiNewsRecording);
				if (!newNewsRecordingServices.ContainsKey(newsRecordingType))
				{
					newsPlasmaRecordingsToRemove.Add(existingMessiNewsRecording);
				}
			}

			foreach (var newsPlasmaRecordingToRemove in newsPlasmaRecordingsToRemove)
			{
				helpers?.Log(nameof(PlasmaIntegration), nameof(RemoveUnusedPlasmaNewsRecordings), "Removing existing Plasma News Recording", newsPlasmaRecordingToRemove?.Name);

				Service parentService = order.AllServices.FirstOrDefault(x => x.Children.Contains(newsPlasmaRecordingToRemove));
				if (parentService == null)
				{
					helpers?.Log(nameof(PlasmaIntegration), nameof(RemoveUnusedPlasmaNewsRecordings), $"Existing plasma news recording won't be removed as no parent service could be found: {newsPlasmaRecordingToRemove?.Name}");
					continue;
				}

				parentService.Children.Remove(newsPlasmaRecordingToRemove);
			}

			RemoveUnusedRoutingServices(helpers, order);
		}

		/// <summary>
		/// Will update timings of existing non plasma services in this order. In other words manually added services.
		/// </summary>
		/// <param name="order">Order which contains all services.</param>
		/// <param name="program">Program containing required information.</param>
		private void UpdateNonPlasmaServices(Order order, Program program)
		{
			foreach (var service in order.AllServices.Where(s => s.IntegrationType == IntegrationType.None && !s.IntegrationIsMaster))
			{
				if (service.IsSharedSource) continue;

				// Update Timings
				if (!service.Start.Equals(program.LiveTransmission.Start) || !service.End.Equals(program.LiveTransmission.End))
				{
					helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNonPlasmaServices), $"Updating Start time of Service {service.Name} from {service.Start.ToString("O")} to {program.LiveTransmission.Start.ToString("O")}");
					helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNonPlasmaServices), $"Updating End time of Service {service.Name} from {service.End.ToString("O")} to {program.LiveTransmission.End.ToString("O")}");

					service.Start = program.LiveTransmission.Start;
					service.End = program.LiveTransmission.End;
				}

				// Allow automatic resource selection for canceled services
				if (service.Status == YLE.Service.Status.Cancelled)
				{
					foreach (var function in service.Functions)
					{
						function.EnforceSelectedResource = false;
					}
				}
			}
		}

		/// <summary>
		/// Update order status based on order changes.
		/// only needs to be updated in case of preliminary status
		/// in that case we need to update the status to confirmed if the source is no longer a dummy
		/// </summary>
		/// <param name="helpers"></param>
		/// <param name="order">Order which need to be updated.</param>
		public static void UpdateOrderStatus(Helpers helpers, Order order)
		{
			// No status change required or allowed
			var orderStatusesThatDoNotRequireUpdate = new[]
			{
				OrderStatus.WaitingOnEbu ,
				OrderStatus.PlannedUnknownSource ,
				OrderStatus.ChangeRequested ,
				OrderStatus.Running,
				OrderStatus.FileProcessing,
				OrderStatus.Completed,
				OrderStatus.CompletedWithErrors
			};

			if (orderStatusesThatDoNotRequireUpdate.Contains(order.Status)) return;

			if (!order.CanBeBooked)
			{
				// Order cannot be booked => preliminary
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateOrderStatus), "Order cannot be booked, setting status to preliminary");
				order.Status = OrderStatus.Preliminary;
				return;
			}

			if (!order.IsBooked || order.IsSaved)
			{
				// New order can be booked => confirmed
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateOrderStatus), "Order can be booked, setting status to confirmed");
				order.Status = OrderStatus.Confirmed;
				return;
			}

			if (order.Status == OrderStatus.Confirmed)
			{
				if (order.HasFixedPlasmaSource && !order.ShouldOrderAlwaysBeDisplayed)
				{
					// WARNING: this if-clause depends on routing services, so won't work when routing for a service is not generated yet

					// order is behind "Fixed Source Plasma" filter in the app
					helpers.Log(nameof(PlasmaIntegration), nameof(UpdateOrderStatus), "Existing 'not always visible' fixed plasma source order is already confirmed, no status change required");
					return;
				}

				var changeSummary = order.Change.Summary as OrderChangeSummary;
				bool nameChanged = changeSummary.NameChanged;
				bool timingChanged = changeSummary.TimingChangeSummary.IsChanged;
				bool servicesAddedOrRemoved = changeSummary.ServicesWereAdded || changeSummary.ServicesWereRemoved;

				if (nameChanged || timingChanged || servicesAddedOrRemoved)
				{
					// order is NOT behind "Fixed Source Plasma" filter in the app
					order.Status = OrderStatus.ChangeRequested;
					helpers.Log(nameof(PlasmaIntegration), nameof(UpdateOrderStatus), "Existing plasma order is confirmed and changed majorly, setting status to change requested");
					return;
				}

				// order is NOT behind "Fixed Source Plasma" filter in the app
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateOrderStatus), "Existing plasma order is confirmed and did not majorly change, no status change required");
				return;
			}

			if (order.Status == OrderStatus.Cancelled)
			{
				// Reinvigorate canceled orders
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateOrderStatus), "Canceled order gets updated, setting status to planned");
				order.Status = OrderStatus.Planned;
			}
		}

		/// <summary>
		/// This method is used to update the existing service with the updated service.
		/// </summary>
		/// <param name="existingOrder">Existing plasma order in the system.</param>
		/// <param name="newSource">Newly created plasma source based on actual plasma data.</param>
		private void UpdateSourceService(Order existingOrder, Service newSource)
		{
			if (existingOrder is null)
			{
				throw new ArgumentNullException(nameof(existingOrder));
			}

			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateSourceService), "Updating Source Service...");

			var existingSource = existingOrder.Sources.FirstOrDefault(x => x.BackupType == BackupType.None);
			if (existingSource == null || newSource == null)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateSourceService), $"No update required: {nameof(existingSource)}={existingSource == null}, {nameof(newSource)}={newSource == null}");
				return;
			}

			bool changeFromManualSelectedSourceToDummyDetected = existingSource.IntegrationType == IntegrationType.None && !existingSource.IntegrationIsMaster && newSource.IsDummy;
			if (changeFromManualSelectedSourceToDummyDetected)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateSourceService), $"Source update can be ignored: existing source is selected manually and may not be overwritten if a plasma dummy source update comes in");
				return;
			}

			// Update resources can be skipped, direct resource selection will not be determined by plasma update it self.
			// Skipping this resource selection will allow us (when applicable) to reuse the already assigned resource of the booked service during add or update/book services flow. Otherwise we could ran into resource overbookings even when the resource should be available.
			IgnoredItems ignoredItems = IgnoredItems.AudioConfig | IgnoredItems.AudioChannels | IgnoredItems.Resources;
			if (existingSource.Status == YLE.Service.Status.Cancelled)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateSourceService), $"Updating resources of canceled source service");
				ignoredItems = IgnoredItems.AudioConfig | IgnoredItems.AudioChannels;

			}

			var updatedSource = UpdateService(existingSource, newSource, ignoredItems);
			existingOrder.Sources.Remove(existingSource);
			existingOrder.Sources.Add(updatedSource.Service);

			if (updatedSource.Service.IsDummy)
			{
				existingOrder.Status = OrderStatus.Preliminary;
			}

			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateSourceService), "Updating Source Service done");
		}

		private void UpdateDestinationService(Order order, Service newDestination)
		{
			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateDestinationService), "Updating Destination Service...");

			Service existingDestination = order.AllServices.FirstOrDefault(x => x.Definition.VirtualPlatform == VirtualPlatform.Destination && x.IntegrationType == IntegrationType.Plasma);
			if (existingDestination == null || newDestination == null)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateDestinationService), "No update required");
				return;
			}

			// Update resources can be skipped, direct resource selection will not be determined by plasma update it self.
			// Skipping this resource selection will allow us (when applicable) to reuse the already assigned resource of the booked service during add or update/book services flow. Otherwise we could ran into resource overbookings even when the resource should be available.
			IgnoredItems ignoredItems = IgnoredItems.AudioConfig | IgnoredItems.AudioChannels | IgnoredItems.Resources;
			if (existingDestination.Status == YLE.Service.Status.Cancelled)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateDestinationService), $"Updating resources of canceled source service");
				ignoredItems = IgnoredItems.AudioConfig | IgnoredItems.AudioChannels;
			}

			var updatedDestination = UpdateService(existingDestination, newDestination, ignoredItems);
			Service parentService = order.AllServices.FirstOrDefault(x => x.Children.Contains(existingDestination)) ?? throw new ServiceNotFoundException($"Unable to find parent of {existingDestination.Name}", true);
			parentService.Children.Remove(existingDestination);
			parentService.Children.Add(updatedDestination.Service);

			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateDestinationService), "Updating Destination Service done");
		}

		private void UpdateStandardTvRecordingService(Program program, Order order, Service newMessiRecording)
		{
			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingService), "Updating Standard TV Recording Service...");

			Service existingMessiRecording = order.AllServices.FirstOrDefault(x => x.Definition.Equals(RecordingMessiLiveServiceDefinition) && x.IntegrationType == IntegrationType.Plasma);
			if (existingMessiRecording == null || newMessiRecording == null)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingService), "No update required");
				return;
			}

			// Update resources can be skipped, direct resource selection will not be determined by plasma update it self. Plasma will set the resource to null each time.
			// Skipping this resource selection will allow us (when applicable) to reuse the already assigned resource of the booked service during add or update/book services flow. Otherwise we could ran into resource overbookings even when the resource should be available.
			IgnoredItems ignoredItems = IgnoredItems.Resources;
			if (existingMessiRecording.Status == YLE.Service.Status.Cancelled)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingService), $"Updating resources of canceled source service");
				ignoredItems = IgnoredItems.None;
			}

			var updatedMessiRecording = UpdateService(existingMessiRecording, newMessiRecording, ignoredItems);

			// Update Recording Config
			updatedMessiRecording.Service.RecordingConfiguration = program.GetStandardTvRecordingConfiguration();

			Service sourceService = order.Sources.FirstOrDefault(x => x.BackupType == BackupType.None);
			Service parentService = order.AllServices.FirstOrDefault(x => x.Children.Contains(existingMessiRecording)) ?? throw new ServiceNotFoundException($"Unable to find parent of {existingMessiRecording.Name}", true);
			parentService.Children.Remove(existingMessiRecording);
			parentService.Children.Add(updatedMessiRecording.Service);

			// Update name of service to record
			updatedMessiRecording.Service.RecordingConfiguration.NameOfServiceToRecord = parentService.Definition.VirtualPlatform == VirtualPlatform.Routing ? sourceService?.Name : parentService.Name;
			updatedMessiRecording.Service.RecordingConfiguration.RecordingName = order.Name;
			updatedMessiRecording.Service.RecordingConfiguration.PlasmaIdForArchive = order.PlasmaId;

			Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingService), "Updating Standard TV Recording Service done");
		}

		private void UpdateStandardTvRecordingBackupService(Program program, Order order, Service newMessiBackupRecording)
		{
			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingBackupService), "Updating Standard TV Recording Backup Service...");

			Service existingMessiBackupRecording = order.AllServices.FirstOrDefault(x => x.Definition.Equals(RecordingMessiLiveBackupServiceDefinition) && x.IntegrationType == IntegrationType.Plasma);
			if (existingMessiBackupRecording == null || newMessiBackupRecording == null)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingBackupService), "No update required");
				return;
			}

			// Update resources can be skipped, direct resource selection will not be determined by plasma update it self.
			// Skipping this resource selection will allow us (when applicable) to reuse the already assigned resource of the booked service during add or update/book services flow. Otherwise we could ran into resource overbookings even when the resource should be available.
			IgnoredItems ignoredItems = IgnoredItems.Resources;
			if (existingMessiBackupRecording.Status == YLE.Service.Status.Cancelled)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingBackupService), $"Updating resources of canceled source service");
				ignoredItems = IgnoredItems.None;
			}

			var updatedMessiRecording = UpdateService(existingMessiBackupRecording, newMessiBackupRecording, ignoredItems);

			// Update Recording Config
			updatedMessiRecording.Service.RecordingConfiguration = program.GetStandardTvBackupRecordingConfiguration();

			Service sourceService = order.Sources.FirstOrDefault(x => x.BackupType == BackupType.None);
			Service parentService = order.AllServices.FirstOrDefault(x => x.Children.Contains(existingMessiBackupRecording)) ?? throw new ServiceNotFoundException($"Unable to find parent of {existingMessiBackupRecording.Name}", true);
			parentService.Children.Remove(existingMessiBackupRecording);
			parentService.Children.Add(updatedMessiRecording.Service);

			// Update name of service to record
			updatedMessiRecording.Service.RecordingConfiguration.NameOfServiceToRecord = parentService.Definition.VirtualPlatform == VirtualPlatform.Routing ? sourceService?.Name : parentService.Name;
			updatedMessiRecording.Service.RecordingConfiguration.RecordingName = order.Name;
			updatedMessiRecording.Service.RecordingConfiguration.PlasmaIdForArchive = order.PlasmaId;

			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateStandardTvRecordingBackupService), "Updating Standard TV Recording Backup Service done");
		}

		private void UpdateNewsRecordingService(Program program, Order order, Service newMessiNewsRecording)
		{
			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), $"Updating News Recording Service...");

			var expectedNewsRecordingType = GetNewsRecordingTypeFromMessiNewsRecordingService(newMessiNewsRecording);

			// find the existing news recording of the correct type
			Service existingMessiNewsRecording = null;
			foreach (var messiNewsRecording in order.AllServices.Where(x => x.Definition.Equals(RecordingMessiNewsServiceDefinition) && x.IntegrationType == IntegrationType.Plasma))
			{
				var newsRecordingType = GetNewsRecordingTypeFromMessiNewsRecordingService(messiNewsRecording);
				if (newsRecordingType == expectedNewsRecordingType)
				{
					existingMessiNewsRecording = messiNewsRecording;
					break;
				}
			}

			if (existingMessiNewsRecording == null && newMessiNewsRecording == null)
			{
				// No service to update
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), "No update required");
			}
			else if (existingMessiNewsRecording != null && newMessiNewsRecording == null)
			{
				// Remove existing Messi News Recording
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), "Removing existing News Recording");

				Service parentService = order.AllServices.FirstOrDefault(x => x.Children.Contains(existingMessiNewsRecording)) ?? throw new ServiceNotFoundException($"Unable to find parent of {existingMessiNewsRecording.Name}", true);
				parentService.Children.Remove(existingMessiNewsRecording);
			}
			else if (existingMessiNewsRecording == null && newMessiNewsRecording != null)
			{
				// Add new Messi News Recording
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), "Adding new News Recording");

				order.MainSourceService.Children.Add(newMessiNewsRecording);

				// Update recording configuration
				newMessiNewsRecording.RecordingConfiguration = program.GetNewsRecordingConfiguration(helpers);
				newMessiNewsRecording.RecordingConfiguration.NameOfServiceToRecord = order.MainSourceService.Name;
				newMessiNewsRecording.RecordingConfiguration.RecordingName = order.Name;
			}
			else
			{
				// Update existing Messi News Recording
				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), $"Updating existing News Recording");

				// Update resources can be skipped, direct resource selection will not be determined by plasma update it self.
				// Skipping this resource selection will allow us (when applicable) to reuse the already assigned resource of the booked service during add or update/book services flow. Otherwise we could ran into resource overbookings even when the resource should be available.
				IgnoredItems ignoredItems = IgnoredItems.AudioConfig | IgnoredItems.AudioChannels | IgnoredItems.Resources;
				if (existingMessiNewsRecording.Status == YLE.Service.Status.Cancelled)
				{
					helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), $"Updating resources of canceled source service");
					ignoredItems = IgnoredItems.AudioConfig | IgnoredItems.AudioChannels;
				}

				var updatedMessiNewsRecording = UpdateService(existingMessiNewsRecording, newMessiNewsRecording, ignoredItems);

				// WARNING: variables existingMessiNewsRecording and updatedMessiNewsRecording can be the same objects! 

				var parentService = order.AllServices.FirstOrDefault(x => x.Children.Contains(existingMessiNewsRecording)) ?? throw new ServiceNotFoundException($"Unable to find parent of {existingMessiNewsRecording.Name}", true);
				parentService.Children.Remove(existingMessiNewsRecording);
				parentService.Children.Add(updatedMessiNewsRecording.Service);

				// Update Recording Configuration
				var updatedRecordingConfiguration = program.GetNewsRecordingConfiguration(helpers);
				updatedMessiNewsRecording.Service.RecordingConfiguration = updatedRecordingConfiguration;

				// Update name of service to record and recording name
				updatedMessiNewsRecording.Service.RecordingConfiguration.NameOfServiceToRecord = parentService.Definition.VirtualPlatform == VirtualPlatform.Routing ? order.MainSourceService?.Name : parentService.Name;
				updatedMessiNewsRecording.Service.RecordingConfiguration.RecordingName = order.Name;

				helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), $"Summary of updated recording service {updatedMessiNewsRecording.Service.Name}: {updatedMessiNewsRecording.Service.GetConfiguration().Serialize()}");
			}

			helpers.Log(nameof(PlasmaIntegration), nameof(UpdateNewsRecordingService), "Updating News Recording Service done");
		}

		private NewsRecordingType GetNewsRecordingTypeFromMessiNewsRecordingService(Service messiNewsRecordingService)
		{
			try
			{
				var recordingFunction = messiNewsRecordingService.Functions.FirstOrDefault();
				var feedTypeProfileParameter = recordingFunction?.Parameters?.FirstOrDefault(p => p.Name == SrmConfiguration.FeedTypeProfileParameterName);
				var newsRecordingType = EnumExtensions.GetEnumValueFromDescription<NewsRecordingType>(feedTypeProfileParameter?.StringValue);
				return newsRecordingType;
			}
			catch (Exception e)
			{
				helpers.Log(nameof(PlasmaIntegration), nameof(GetNewsRecordingTypeFromMessiNewsRecordingService), $"Exception retrieving news recording type from Messi News Recording service: {e}");
			}

			return NewsRecordingType.PGM;
		}

		#region Service Generation And Updates
		private Service GenerateFixedLineLyReceptionService(Program program, string plasmaUserCodeValue)
		{
			var receptionService = GenerateDefaultIntegrationService(FixedLineLyServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			receptionService.RequiresRouting = false;

			// configure source function - Plasma User Code
			var sourceFunction = receptionService.Functions.FirstOrDefault() ?? throw new NotFoundException("Unable to find source function");
			var plasmaUserCodeProfileParameter = sourceFunction.Parameters.FirstOrDefault(p => p.Name == SrmConfiguration.PlasmaUserCodeProfileParameterName);
			if (plasmaUserCodeProfileParameter == null) throw new ProfileParameterNotFoundException(SrmConfiguration.PlasmaUserCodeProfileParameterName);
			plasmaUserCodeProfileParameter.Value = plasmaUserCodeValue;

			return receptionService;
		}

		private Service GenerateFixedLineMediapolisReceptionService(Program program)
		{
			var receptionService = GenerateDefaultIntegrationService(FixedLineMediapolisServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			receptionService.RequiresRouting = false;

			// configure source function - Fixed Line YLE Mediapolis source location
			var sourceFunction = receptionService.Functions.FirstOrDefault() ?? throw new NotFoundException("Unable to find source function");
			var fixedLineMediapolisSourceLocationProfileParameter = sourceFunction.Parameters.FirstOrDefault(p => p.Name == SrmConfiguration.FixedLineYleMediapolisSourceLocationProfileParameterName);
			if (fixedLineMediapolisSourceLocationProfileParameter == null) throw new ProfileParameterNotFoundException(SrmConfiguration.FixedLineYleMediapolisSourceLocationProfileParameterName);
			fixedLineMediapolisSourceLocationProfileParameter.Value = SrmConfiguration.FixedLineYleMediapolisSourceLocationMediapolisStudioProfileParameterValue;

			return receptionService;
		}

		private Service GenerateFixedLineAtvuReceptionService(Program program)
		{
			var receptionService = GenerateDefaultIntegrationService(FixedLineAtvuServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			receptionService.RequiresRouting = false;

			return receptionService;
		}

		private Service GenerateDummySourceService(Transmission transmission)
		{
			var start = transmission.Start;
			var end = transmission.End;

			var service = Service.GenerateDummyReception(helpers, start, end);
			service.RequiresRouting = false;
			service.IntegrationType = IntegrationType.None;
			service.IntegrationIsMaster = true;

			return service;
		}

		private Service GenerateYleHelsinkiDestinationService(Program program, Service sourceService)
		{
			var destinationService = GenerateDefaultIntegrationService(YleHelsinkiDestinationServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			destinationService.RequiresRouting = !(sourceService.Definition.Equals(FixedLineLyServiceDefinition) || sourceService.Definition.Equals(FixedLineAtvuServiceDefinition)); // requires routing is only false if the source is a specific source (= direct line from source to destination)

			// configure destination function
			var destinationFunction = destinationService.Functions.FirstOrDefault() ?? throw new NotFoundException("Unable to find destination function");
			var destinationLocationProfileParameter = destinationFunction.Parameters.FirstOrDefault(p => p.Name == SrmConfiguration.YleHelsinkiDestinationLocationProfileParameterName);
			if (destinationLocationProfileParameter == null)
			{
				throw new ProfileParameterNotFoundException(SrmConfiguration.YleHelsinkiDestinationLocationProfileParameterName);
			}

			// if there is a specific source then a dummy resource is used
			// if not, then a line is allocated from HMX to playout
			destinationLocationProfileParameter.Value = sourceService.Definition.Equals(FixedLineLyServiceDefinition) || sourceService.Definition.Equals(FixedLineAtvuServiceDefinition) ? SrmConfiguration.DestinationLocationDummyPlayoutProfileParameterValue : SrmConfiguration.DestinationLocationPlayoutProfileParameterValue;

			return destinationService;
		}

		private Service GenerateYleMediapolisDestinationService(Program program)
		{
			var destinationService = GenerateDefaultIntegrationService(YleMediapolisDestinationServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			destinationService.RequiresRouting = true;

			// configure destination function
			var destinationFunction = destinationService.Functions.FirstOrDefault() ?? throw new NotFoundException("Unable to find destination function");
			var destinationLocationProfileParameter = destinationFunction.Parameters.FirstOrDefault(p => p.Name == SrmConfiguration.YleMediapolisDestinationLocationProfileParameterName) ?? throw new ProfileParameterNotFoundException(SrmConfiguration.YleMediapolisDestinationLocationProfileParameterName);

			// Location is Mediapolis LT
			destinationLocationProfileParameter.Value = SrmConfiguration.YleMediapolisDestinationLocationMediapolisLtProfileParameterValue;

			return destinationService;
		}

		private Service GenerateStandardTvRecordingService(Program program)
		{
			helpers.Log(nameof(PlasmaIntegration), nameof(GenerateStandardTvRecordingService), "Generating Standard TV Recording");

			// messi live recording service
			var recordingService = GenerateDefaultIntegrationService(RecordingMessiLiveServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			recordingService.RequiresRouting = false;
			recordingService.RecordingConfiguration = program.GetStandardTvRecordingConfiguration();

			// configure recording function
			var recordingFunction = recordingService.Functions.FirstOrDefault() ?? throw new NotFoundException("Unable to find recording function");
			var recordingTvChannelProfileParameter = recordingFunction.Parameters.FirstOrDefault(p => p.Name == SrmConfiguration.RecordingTvChannelProfileParameterName);
			if (recordingTvChannelProfileParameter != null)
			{
				switch (program.LiveTransmission.Channel)
				{
					case Channels.YleTv1:
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelTv1ProfileParameterValue;
						break;
					case Channels.YleTv2:
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelTv2ProfileParameterValue;
						break;
					case Channels.YleTeema:
					case Channels.YleFem:
					case Channels.YleTeemaFem:
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelTvTeemaFemProfileParameterValue;
						break;
					default:
						// Use default profile parameter value = None
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelNoneProfileParameterValue;
						break;
				}
			}

			return recordingService;
		}

		private Service GenerateStandardTvRecordingBackupService(Program program)
		{
			helpers.Log(nameof(PlasmaIntegration), nameof(GenerateStandardTvRecordingBackupService), "Generating Standard TV Recording Backup");

			var recordingService = GenerateDefaultIntegrationService(RecordingMessiLiveBackupServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			recordingService.RequiresRouting = false;
			recordingService.RecordingConfiguration = program.GetStandardTvBackupRecordingConfiguration();

			// configure recording function
			var recordingFunction = recordingService.Functions.FirstOrDefault() ?? throw new NotFoundException("Unable to find recording function");
			var recordingTvChannelProfileParameter = recordingFunction.Parameters.FirstOrDefault(p => p.Name == SrmConfiguration.RecordingTvChannelProfileParameterName);
			if (recordingTvChannelProfileParameter != null)
			{
				switch (program.LiveTransmission.Channel)
				{
					case Channels.YleTv1:
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelTv1ProfileParameterValue;
						break;
					case Channels.YleTv2:
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelTv2ProfileParameterValue;
						break;
					case Channels.YleTeema:
					case Channels.YleFem:
					case Channels.YleTeemaFem:
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelTvTeemaFemProfileParameterValue;
						break;
					default:
						// Use default profile parameter value = None
						recordingTvChannelProfileParameter.Value = SrmConfiguration.RecordingTvChannelNoneProfileParameterValue;
						break;
				}
			}

			return recordingService;
		}

		private Dictionary<NewsRecordingType, Service> GenerateNewsRecordingServices(Program program)
		{
			var newsRecordings = new Dictionary<NewsRecordingType, Service>();

			var requiredNewsRecordingTypes = new List<NewsRecordingType> { NewsRecordingType.Clean }; // Always generate Clean Recording
			if (program.ShouldAddPgmNewsRecording(helpers))
			{
				// PGM news will only be added if the program title matches the order manager news recording configuration
				requiredNewsRecordingTypes.Add(NewsRecordingType.PGM);
			}

			Log(nameof(GenerateNewsRecordingServices), $"Required news recording types: '{string.Join(", ", requiredNewsRecordingTypes)}'");

			foreach (var newsRecordingType in requiredNewsRecordingTypes)
			{
				var newsRecordingService = GenerateNewsRecordingService(program, newsRecordingType);
				if (newsRecordingService != null && !newsRecordings.ContainsKey(newsRecordingType))
				{
					newsRecordings.Add(newsRecordingType, newsRecordingService);
				}
			}

			return newsRecordings;
		}

		private Service GenerateNewsRecordingService(Program program, NewsRecordingType newsRecordingType)
		{
			if (!program.IsLiveNews(helpers))
			{
				Log(nameof(GenerateNewsRecordingService), "Program is not live news, no news recording service generation allowed");
				return null; // No need to create News Recording in this use case
			}

			Log(nameof(GenerateNewsRecordingService), "Generating News Recording");

			var recordingService = GenerateDefaultIntegrationService(RecordingMessiNewsServiceDefinition, program.LiveTransmission.Start, program.LiveTransmission.End);
			recordingService.RequiresRouting = true;
			recordingService.RecordingConfiguration = program.GetNewsRecordingConfiguration(helpers);

			// update news recording type
			var recordingFunction = recordingService.Functions.FirstOrDefault();
			var feedTypeProfileParameter = recordingFunction?.Parameters?.FirstOrDefault(p => p.Name == SrmConfiguration.FeedTypeProfileParameterName);
			if (feedTypeProfileParameter != null) feedTypeProfileParameter.Value = newsRecordingType.ToString();

			return recordingService;
		}

		#endregion
	}
}