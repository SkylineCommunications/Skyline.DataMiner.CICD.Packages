namespace Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Integrations.Feenix
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Newtonsoft.Json;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Configuration;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Exceptions;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Contracts;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Event;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Function;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Integrations;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Integrations.Helpers;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.OrderManagerElement;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.OrderUpdates;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Profile;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Service;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.ServiceDefinition;
    using Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Utilities;
    using Skyline.DataMiner.Net.Messages;
    using Skyline.DataMiner.Net.Messages.SLDataGateway;
    using Skyline.DataMiner.Net.ResourceManager.Objects;
    using Skyline.DataMiner.Utils.YLE.Integrations;
    using Skyline.DataMiner.Utils.YLE.Integrations.Ceiton;
    using Skyline.DataMiner.Utils.YLE.Integrations.Feenix;
    using BackupType = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.BackupType;
    using Contract = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Contracts.Contract;
    using OrderStatus = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Order.Status;
    using Service = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Service.Service;
    using Task = Tasks.Task;
    using TaskStatus = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Tasks.Status;
    using VirtualPlatform = Skyline.DataMiner.DeveloperCommunityLibrary.YLE.ServiceDefinition.VirtualPlatform;

    /// <summary>
    /// Feenix Integration class.
    /// </summary>
    public class FeenixIntegration : Integration
    {
        public static readonly int LiveStreamOrdersTableParameterId = 1000;
        public static readonly int LiveStreamOrdersPlasmaIdPid = 1073;
        public static readonly int LiveStreamOrdersPlasmaIdIdx = 72;

        private readonly ProfileParameter feenixSourceParameter;
        private readonly ProfileParameter resourceInputConnectionsSdiParameter;

        /// <summary>
        /// Creates a new instance of the Feenix Integration class.
        /// </summary>
        public FeenixIntegration(Helpers helpers, OrderManagerElement orderManagerElement) : base(helpers, orderManagerElement)
        {
            feenixSourceParameter = helpers.ProfileManager.GetProfileParameter(SrmConfiguration.FeenixSourceProfileParameterName);
            resourceInputConnectionsSdiParameter = helpers.ProfileManager.GetProfileParameter(SrmConfiguration.ResourceInputConnectionsSdiProfileParameterName);
        }

        public override IntegrationType IntegrationType => IntegrationType.Feenix;

        protected override string IntegrationText => "Automatically generated by Feenix integration.";

        private ServiceDefinition AreenaDestinationServiceDefinition
        {
            get
            {
                return helpers.ServiceDefinitionManager.GetServiceDefinition(SrmConfiguration.AreenaDestinationServiceDefinitionId);
            }
        }

        private IEnumerable<ServiceDefinition> ReceptionServiceDefinitions
        {
            get
            {
                return helpers.ServiceDefinitionManager.GetReceptionServiceDefinitions();
            }
        }

        public override void HandleUpdate(string id, string integrationData)
        {
            var feenixOrder = ParseFeenixOrder(integrationData, out bool isStoppedOrRemoved);

            var existingOrder = helpers.OrderManager.GetFeenixOrder(id);
            if (existingOrder != null)
            {
                if (existingOrder.Status == OrderStatus.Completed || existingOrder.Status == OrderStatus.CompletedWithErrors)
                {
                    SendResponseToOrderManagerElement(id, UpdateStatus.OK, "HandleUpdate|No action performed|Unable to update completed order");
                    return;
                }

                if (existingOrder.IntegrationType != IntegrationType.Feenix)
                {
                    SendResponseToOrderManagerElement(id, UpdateStatus.OK, $"HandleUpdate|No action performed|Feenix shouldn't update linked {existingOrder.IntegrationType} order '{existingOrder.Name}'");
                    return;
                }

                RetrieveLock(existingOrder);
            }

            if (feenixOrder != null)
            {
                if (!feenixOrder.IsEligibleForOrderCreation(existingOrder != null))
                {
                    SendResponseToOrderManagerElement(id, UpdateStatus.OK, $"HandleUpdate|No action performed|Feenix Order is not eligible for Order creation");
                    return;
                }

                HandleEligibleFeenixOrder(feenixOrder, isStoppedOrRemoved, existingOrder);
            }
            else if (isStoppedOrRemoved && existingOrder != null)
            {
                if (CancelOrder(existingOrder))
                {
                    SendResponseToOrderManagerElement(id, UpdateStatus.Removed, "HandleUpdate|Action succeeded|Canceling order succeeded");
                }
                else
                {
                    SendResponseToOrderManagerElement(id, UpdateStatus.Failed, "HandleUpdate|Action failed|Canceling order failed");
                }
            }
            else
            {
                SendResponseToOrderManagerElement(id, UpdateStatus.OK, "HandleUpdate|No action required");
            }
        }

        private void HandleEligibleFeenixOrder(FeenixOrder feenixOrder, bool isStoppedOrRemoved, Order existingOrder)
        {
            if (!isStoppedOrRemoved)
            {
                AddOrUpdateOrder(feenixOrder, existingOrder);
            }
            else
            {
                StopOrCancelOrder(feenixOrder, existingOrder);
            }
        }

        public FeenixOrder ParseFeenixOrder(string integrationData, out bool isStoppedOrRemoved)
        {
            isStoppedOrRemoved = false;
            if (String.IsNullOrEmpty(integrationData))
            {
                isStoppedOrRemoved = true;
                return null;
            }

            FeenixOrder feenixOrder = null;
            try
            {
                feenixOrder = FeenixOrder.Deserialize(integrationData);
                if (feenixOrder.IsRemoved || feenixOrder.IsStopped) isStoppedOrRemoved = true;
            }
            catch (Exception e)
            {
                Log(nameof(ParseFeenixOrder), $"Unable to parse Feenix Order from {integrationData} due to {e}");
            }

            return feenixOrder;
        }

        /// <summary>
        /// Creates a new order or updates an existing one based on the information received from Feenix.
        /// This method will add or update the order in SRM.
        /// </summary>
        /// <param name="feenixOrder">Feenix Order containing the information received from Feenix.</param>
        /// <param name="existingOrder">Already existing Dataminer Feenix order</param>
        private void AddOrUpdateOrder(FeenixOrder feenixOrder, Order existingOrder)
        {
            var contract = RetrieveOpenContractDuringFeenixOrder(feenixOrder);
            if (contract == null)
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Failed, $"AddOrUpdateProgram|No action executed|No open contract from {feenixOrder.Start} to {feenixOrder.End}");
                return;
            }

            Order newOrder = CreateFeenixOrder(feenixOrder, contract, existingOrder);
            existingOrder = CheckToRemoveOldOrder(existingOrder);

            bool updateRequired = false;
            if (existingOrder == null)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateOrder), $"Creating new order for Feenix {feenixOrder.Id}");

                // Book new order
                updateRequired = true;
                CheckIfOrderShouldStartNow(newOrder);
            }
            else
            {
                // Update existing order
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateOrder), $"Updating Order {existingOrder.Name} [{existingOrder.Id}]");

                helpers.AddOrderReferencesForLogging(existingOrder.Id);

                newOrder = UpdateExistingOrder(existingOrder, newOrder, out bool orderChanged);
                updateRequired |= orderChanged;
            }

            newOrder.SetMcrLateChangeRequired(helpers, userIsMcr: false);
            updateRequired |= UpdateEvent(newOrder, feenixOrder);

            if (updateRequired)
            {
                try
                {
                    // Update order
                    helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateOrder), $"Booking Order {newOrder.Name} [{newOrder.Id}] with status {newOrder.Status}");

                    var result = AddOrUpdateSrmOrder(newOrder);
                    if (!result.UpdateWasSuccessful)
                    {
                        SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Failed, $"AddOrUpdateOrder|Action failed|Adding or updating order failed|{String.Join(Environment.NewLine, result.Exceptions)}");
                        return;
                    }

                    helpers.AddOrderReferencesForLogging(newOrder.Id);

                    SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.OK, "AddOrUpdateOrder|Action succeeded|Adding or updating order succeeded", newOrder.Id, newOrder.Event?.Id);
                }
                catch (Exception e)
                {
                    SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Failed, $"AddOrUpdateOrder|Action failed|Adding or updating order failed: {e}");
                }
            }
            else
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.OK, $"AddOrUpdateOrder|No action required");
            }
        }

        private void CheckIfOrderShouldStartNow(Order newOrder)
        {
            if (newOrder.StartWithPreRoll < DateTime.Now)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateOrder), "Order Start Now flag is set");
                newOrder.StartNow = true;
            }
        }

        private Order UpdateExistingOrder(Order existingOrder, Order newOrder, out bool updateRequired)
        {
            // Start change tracking for existing order
            existingOrder.AcceptChanges();
            foreach (var service in existingOrder.AllServices) service.AcceptChanges();

            var existingSourceService = existingOrder.MainSourceService;
            var newSourceService = newOrder.MainSourceService;

            bool existingSourceServiceIsDummy = existingSourceService == null || existingSourceService.IsDummy;
            bool shouldOrderBeRecreatedAsPreliminary = !existingSourceServiceIsDummy && existingSourceService.IntegrationType == IntegrationType.Feenix && existingSourceService.IntegrationIsMaster && newSourceService.IsDummy;

            Order orderToBook;
            if (shouldOrderBeRecreatedAsPreliminary)
            {
                RecreateOrderAsPreliminary(existingOrder, newOrder);
                orderToBook = newOrder;
                updateRequired = true;
            }
            else
            {
                orderToBook = UpdateExistingFeenixOrder(existingOrder, newOrder, out updateRequired);
                if (updateRequired)
                {
                    UpdateServicesToRecordOrTransmit(existingOrder, newOrder);
                }
            }

            return orderToBook;
        }

        private void RecreateOrderAsPreliminary(Order existingOrder, Order newOrder)
        {
            // Remove existing order and book new order
            helpers.Log(nameof(FeenixIntegration), nameof(RecreateOrderAsPreliminary), $"Source service is dummy, recreating order as preliminary");
            RemoveExistingOrder(existingOrder.Id);
            AddExistingNonFeenixServicesToFeenixOrder(existingOrder, newOrder);
            UpdateServicesToRecordOrTransmit(existingOrder, newOrder);

            helpers.Log(nameof(FeenixIntegration), nameof(RecreateOrderAsPreliminary), $"Assigning existing event {existingOrder.Event?.Name} with ID {existingOrder.Event?.Id} to preliminary order");

            newOrder.Event = existingOrder.Event;
        }

        /// <summary>
        /// In some test cases, an order created correctly for the first time.
        /// The order went through its expected life cycle.
        /// After the order was done a Feenix update comes in with new timings that are in the future.
        /// To support these case, it would be better to remove the old order and create the new one.
        /// </summary>
        /// <param name="order">Existing order that will be removed if it was already completed.</param>
        /// <returns>Null if order was removed, else the untouched order instance.</returns>
        private Order CheckToRemoveOldOrder(Order order)
        {
            if (order == null) return null;

            bool orderEndsInThePast = order.End <= DateTime.Now;
            if (!orderEndsInThePast) return order;

            helpers.Log(nameof(FeenixIntegration), nameof(CheckToRemoveOldOrder), "Removing Old Order: " + order.Name);

            List<Guid> servicesToKeep = order.AllServices.Where(x => x != null && x.IsSharedSource && x.End >= DateTime.Now).Select(x => x.Id).ToList(); // Keep all ELRs that end in the future
            helpers.OrderManager.DeleteOrder(order, servicesToKeep);

            // Remove event if it only contains the single order
            if (order.Event.OrderIds.Count <= 1)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(CheckToRemoveOldOrder), "Removing Old Event: " + order.Event.Name);
                helpers.EventManager.DeleteEvent(order.Event.Id);
            }

            return null;
        }

        /// <summary>
        /// Adds or updates the provided order in SRM with the provided action.
        /// </summary>
        /// <param name="order">SRM order that needs to be added or updated.</param>
        /// <returns>Boolean indicating if the update was successful or not.</returns>
        private UpdateResult AddOrUpdateSrmOrder(Order order)
        {
            try
            {
                bool occupiedResourcesNeedToBeAssigned = false;
                if (order.IsBooked && order.AllServices.Exists(s => s.IsOrShouldBeRunning))
                {
                    // if running order is extended, keep assigned resources
                    foreach (var service in order.AllServices)
                    {
                        occupiedResourcesNeedToBeAssigned |= service.UsesOccupiedResources(helpers);
                    }
                }

                UpdateResult updateResult;
                if (occupiedResourcesNeedToBeAssigned)
                {
                    helpers.ClearCache(); // clear cache of available resources

                    var handler = new AssignOccupiedResourcesToOrderHandler(helpers, order);

                    updateResult = handler.Execute();
                }
                else
                {
                    updateResult = order.AddOrUpdate(helpers, false, OrderUpdateHandler.OptionFlags.ForceGetExistingEvent);
                }

                return updateResult;
            }
            catch (Exception e)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateSrmOrder), "Something went wrong: " + e);
                return new UpdateResult
                {
                    UpdateWasSuccessful = false,
                    Exceptions = new List<Exception> { e }
                };
            }
        }

        /// <summary>
        /// Updates the Feenix Service statuses and maybe the Order status as well, based on the use case.
        /// </summary>
        /// <param name="feenixOrder">Feenix Order to be updated.</param>
        /// <param name="order">Already existing Dataminer Feenix order</param>
        /// <returns>Boolean indicating if the update was successful.</returns>
        private void StopOrCancelOrder(FeenixOrder feenixOrder, Order order)
        {
            if (order == null)
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Removed, "StopOrCancelOrder|No action required|Order does not exist");
                return;
            }

            helpers.AddOrderReferencesForLogging(order.Id);

            try
            {
                if (feenixOrder.IsRemoved)
                {
                    if (CancelOrder(order))
                    {
                        SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Removed, "StopOrCancelOrder|Action succeeded|Canceling order succeeded");
                    }
                    else
                    {
                        SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Failed, "StopOrCancelOrder|Action failed|Canceling order failed");
                    }
                }
                else if (feenixOrder.IsStopped)
                {
                    StopFeenixOrder(order, feenixOrder);
                }
                else
                {
                    SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.OK, "StopOrCancelOrder|No action required");
                }
            }
            catch (Exception e)
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Failed, $"StopOrCancelOrder|Action failed|Removing or stopping order failed: {e}");
            }
        }

        private void StopFeenixOrder(Order order, FeenixOrder feenixOrder)
        {
            if (order.Start > DateTime.Now)
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.OK, "StopFeenixOrder|Action succeeded|Order is not running yet");
                return;
            }

            if (order.End < DateTime.Now)
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.OK, "StopFeenixOrder|Action succeeded|Order is already stopped");
                return;
            }

            if (StopOrder(order))
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.OK, "StopFeenixOrder|Action succeeded|Stopping order succeeded");
            }
            else
            {
                SendResponseToOrderManagerElement(feenixOrder.Id, UpdateStatus.Failed, "StopFeenixOrder|Action failed|Stopping order failed");
            }
        }

        /// <summary>
        /// Updates the status of all order services to Cancelled.
        /// </summary>
        /// <param name="order">Order to be updated.</param>
        /// <returns>Boolean indicating if the update was successful or not.</returns>
        private bool CancelOrder(Order order)
        {
            order.ReasonForCancellationOrRejection = "Feenix integration has canceled this order";

            return order.UpdateStatus(helpers, OrderStatus.Cancelled);
        }

        /// <summary>
        /// Updates the status of the Feenix services to ServiceCompleted and the Order Status to Completed in SRM.
        /// </summary>
        /// <param name="order">Order to be stopped.</param>
        /// <returns>Boolean indicating if the update was successful or not.</returns>
        private bool StopOrder(Order order)
        {
            try
            {
                order.StopNow = true;
                var tasks = order.StopOrderAndLinkedServices(helpers).Tasks;
                foreach (var task in tasks.Where(x => x.Status == TaskStatus.Fail))
                {
                    helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateSrmOrder), "Failed to execute task: " + task.Description);
                }

                if (tasks.Any(x => x.Status == TaskStatus.Fail && x.IsBlocking))
                {
                    // Some Order creation tasks failed
                    if (!RollBackTasks(tasks))
                    {
                        helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateSrmOrder), "Rollback failed");
                    }

                    return false;
                }
            }
            catch (Exception e)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateSrmOrder), "Something went wrong: " + e);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Rolls back the tasks that failed when adding or updating an order in SRM.
        /// </summary>
        /// <param name="tasks">List of tasks that were executed when adding or updating an Order in SRM.</param>
        /// <returns>True if the rollback was successful, else false.</returns>
        private static bool RollBackTasks(IEnumerable<Task> tasks)
        {
            List<Task> rollbackTasks = tasks.Where(t => t.Status == TaskStatus.Ok).Select(t => t.CreateRollbackTask()).Where(t => t != null).Reverse().ToList();
            foreach (Task rollbackTask in rollbackTasks)
            {
                if (!rollbackTask.Execute()) return false;
            }

            return true;
        }

        private Contract RetrieveOpenContractDuringFeenixOrder(FeenixOrder feenixOrder)
        {
            helpers.Log(nameof(FeenixIntegration), nameof(RetrieveOpenContractDuringFeenixOrder), $"Trying to find open contract from {feenixOrder.Start} or before until {feenixOrder.End} or later between contracts {string.Join(",", CompanyDetails.Contracts.Select(c => c.Name))}");

            Contract contract = null;
            var openContractsDuringTransmission = CompanyDetails.Contracts.Where(c => c.Start <= feenixOrder.Start && c.End >= feenixOrder.End && c.Status == ContractStatus.Open).ToList();
            if (openContractsDuringTransmission.Any())
            {
                contract = openContractsDuringTransmission.FirstOrDefault(c => c.Type == ContractType.BaseContract);
                if (contract == null) contract = openContractsDuringTransmission.FirstOrDefault();
            }

            helpers.Log(nameof(FeenixIntegration), nameof(RetrieveOpenContractDuringFeenixOrder), $"Found contract {contract?.Name}");

            return contract;
        }

        /// <summary>
        /// Creates a new SRM order based on the information received from Feenix.
        /// </summary>
        /// <param name="feenixOrder">Information from Feenix.</param>
        /// <param name="contract"></param>
        /// <param name="existingOrder"></param>
        /// <returns>New SRM order based on the information retrieved from Feenix.</returns>
        private Order CreateFeenixOrder(FeenixOrder feenixOrder, Contract contract, Order existingOrder = null)
        {
            string title = GenerateTitle(feenixOrder);
            var order = new Order
            {
                ManualName = $"{title}[{feenixOrder.Id}]",
                Start = feenixOrder.Start,
                End = feenixOrder.End,
                Sources = new List<Service>(),
                Comments = "Automatically created by Feenix integration",
                Type = OrderType.Video,
                IntegrationType = IntegrationType.Feenix,
                Definition = new ServiceDefinition { BookingManagerElementName = SrmConfiguration.OrderBookingManagerElementName },
                PlasmaId = feenixOrder.PlasmaId,
                YleId = feenixOrder.Id,
                Company = CompanyDetails.Company,
                Contract = contract.Name,
                IsInternal = false,
                CreatedByUserName = "Feenix",
                LastUpdatedBy = "Feenix",
                BillingInfo = new BillingInfo
                {
                    BillableCompany = CompanyDetails.Company,
                    CustomerCompany = String.Empty,
                },
                PublicationStart = feenixOrder.Start,
                PublicationEnd = feenixOrder.End,
            };

            order.SetSecurityViewIds(GetSecurityViewIds(contract)); // All Feenix orders should be visible for whole YLE

            order.AcceptChanges();

            // Create Source Service
            FunctionResource sourceResource = GetSourceResource(feenixOrder.RoutingInput);
            Service existingSourceService = existingOrder?.MainSourceService;
            Service sourceService = CreateSourceService(feenixOrder, sourceResource, existingSourceService); // Never null
            sourceService.AcceptChanges();

            order.SourceService = sourceService;

            // Create Destination Service
            FunctionResource destinationResource = GetDestinationResource(feenixOrder.RoutingOutput);
            Service existingDestinationService = existingOrder?.FeenixDestinationService;
            Service destinationService = CreateDestinationService(feenixOrder, destinationResource, existingDestinationService); // Can be null
            destinationService?.AcceptChanges();

            if (destinationService != null) order.SourceService.Children.Add(destinationService);

            // Feenix Use Case 1: Set the status of the Order to Confirmed if the Resources are known or Preliminary if any Resource is unknown
            // We'll save the order (and set the status to preliminary) when we don't have enough information to completely configure the Services.
            if (IsFeenixOrderComplete(order))
            {
                order.Status = OrderStatus.Confirmed;
            }
            else
            {
                order.Status = OrderStatus.Preliminary;
            }

            Log(nameof(CreateFeenixOrder), $"Created Feenix Order {order.Name} with status {order.Status} from {order.Start} to {order.End}");
            foreach (var service in order.AllServices) Log(nameof(CreateFeenixOrder), $"Service {service.Definition?.Name} from {service.Start} to {service.End}");

            return order;
        }

        private static string GenerateTitle(FeenixOrder feenixOrder)
        {
            if (!string.IsNullOrWhiteSpace(feenixOrder.MainFinnishTitle) && !feenixOrder.MainFinnishTitle.Equals(Feenix.NotApplicableString))
            {
                return feenixOrder.MainFinnishTitle;
            }
            else if (!string.IsNullOrWhiteSpace(feenixOrder.MainSwedishTitle) && !feenixOrder.MainSwedishTitle.Equals(Feenix.NotApplicableString))
            {
                return feenixOrder.MainSwedishTitle;
            }
            else
            {
                return feenixOrder.MainSamiTitle;
            }
        }

        private Event DetermineFeenixEvent(FeenixOrder feenixOrder, Order order)
        {
            Event @event;
            if (feenixOrder.HasValidCeitonProjectId)
            {
                // Use Ceiton event if Project Number is available
                @event = helpers.EventManager.GetEvent(feenixOrder.CeitonProjectId);
                if (@event == null)
                {
                    helpers.Log(nameof(FeenixIntegration), nameof(DetermineFeenixEvent), $"No existing Event was found with project number: {feenixOrder.CeitonProjectId}, creating new Feenix event");

                    string title = GenerateTitle(feenixOrder);
                    HashSet<string> productIds = (feenixOrder.HasValidCeitonProductId) ? new HashSet<string>(new[] { feenixOrder.CeitonProductId }) : new HashSet<string>();
                    @event = GenerateNewCeitonEvent(title, feenixOrder.CeitonProjectId, productIds, feenixOrder.Start, feenixOrder.End);
                    UpdateEventContractAndRights(@event);
                    @event.SecurityViewIds = new HashSet<int>(order.SecurityViewIds);
                    @event.Info = "Automatically created by Feenix integration";
                    @event.IntegrationType = IntegrationType.Feenix;

                    CeitonElement ceitonElement = new CeitonElement(orderManagerElement.CeitonElement);
                    ceitonElement.PollProject(feenixOrder.CeitonProjectId);
                    ceitonElement.PollProduct(feenixOrder.CeitonProductId);
                }
                else
                {
                    helpers.Log(nameof(FeenixIntegration), nameof(DetermineFeenixEvent), $"Found existing Event with project number: {feenixOrder.CeitonProjectId}, using event {@event.Name} [{@event.Id}]");

                    // Use existing Ceiton event -> add feenix product number to the Ceiton event
                    if (feenixOrder.HasValidCeitonProductId)
                    {
                        HashSet<string> productNumbers = new HashSet<string>(@event.ProductNumbers);
                        productNumbers.Add(feenixOrder.CeitonProductId);
                        @event.ProductNumbers = productNumbers;

                        CeitonElement ceitonElement = new CeitonElement(orderManagerElement.CeitonElement);
                        ceitonElement.PollProduct(feenixOrder.CeitonProductId);
                    }
                }
            }
            else
            {
                @event = GenerateNewFeenixEvent(feenixOrder, order);
            }

            return @event;
        }

        private Event GenerateNewFeenixEvent(FeenixOrder feenixOrder, Order order)
        {
            helpers.Log(nameof(FeenixIntegration), nameof(GenerateNewFeenixEvent), "Creating new Feenix event");

            string title = GenerateTitle(feenixOrder);
            return new Event(helpers)
            {
                Name = $"{title}[{feenixOrder.Id}]",
                Company = CompanyDetails.Company,
                Contract = order.Contract,
                IntegrationType = IntegrationType.Feenix,
                Start = feenixOrder.Start,
                End = feenixOrder.End,
                Status = YLE.Event.Status.Confirmed,
                Info = "Automatically created by Feenix integration",
                SecurityViewIds = new HashSet<int>(order.SecurityViewIds) // All Feenix orders should be visible for whole YLE
            };
        }

        private HashSet<int> GetSecurityViewIds(Contract contract)
        {
            HashSet<int> viewIds = new HashSet<int>();

            // All orders should be visible to MCR users
            viewIds.Add(CompanyDetails.McrSecurityViewId);

            // All orders should be visible to YLE
            viewIds.Add(CompanyDetails.SecurityViewId);

            // If the company has linked orders, the EBU orders should be visible to them as well
            foreach (Company linkedCompany in contract.LinkedCompanies)
            {
                viewIds.Add(linkedCompany.SecurityViewId);
            }

            return viewIds;
        }

        /// <summary>
        /// Updates the general information of the existing order based on the information provided by Feenix.
        /// </summary>
        /// <param name="existingOrder">Order to be updated.</param>
        /// <param name="newOrder">Contains order information as received from Feenix.</param>
        /// <param name="updateRequired">Value indicating the order was updated or not.</param>
        /// <returns>The updated existing order.</returns>
        private Order UpdateExistingFeenixOrder(Order existingOrder, Order newOrder, out bool updateRequired)
        {
            updateRequired = false;

            updateRequired |= ReinvigorateCanceledOrder(existingOrder);

            updateRequired |= AddOrUpdateOrderName(existingOrder, newOrder.Name);

            updateRequired |= AddOrUpdateIntegrationType(existingOrder);

            updateRequired |= AddOrUpdatePlasmaId(existingOrder, newOrder.PlasmaId);

            updateRequired |= UpdatePublicationTimes(existingOrder, newOrder.PublicationStart, newOrder.PublicationEnd);

            var newSourceService = newOrder.MainSourceService;
            var newDestinationService = newOrder.FeenixDestinationService;

            bool servicesChanged = UpdateSourceAndDestinationInOrder(existingOrder, newSourceService, newDestinationService);
            updateRequired |= servicesChanged;

            bool serviceTimingChanged = UpdateServiceTiming(existingOrder, newOrder.Start, newOrder.End);
            updateRequired |= serviceTimingChanged;

            bool criticalServiceChanges = servicesChanged || serviceTimingChanged;
            updateRequired |= UpdateOrderStatus(existingOrder, criticalServiceChanges);

            existingOrder.LastUpdatedBy = "Feenix";

            updateRequired |= UpdateOrderTiming(existingOrder);

            return existingOrder;
        }

        private static bool UpdatePublicationTimes(Order existingOrder, DateTime newPublicationStart, DateTime newPublicationEnd)
        {
            bool publicationStartTimeChanged = existingOrder.PublicationStart != newPublicationStart;
            existingOrder.PublicationStart = newPublicationStart;

            bool publicationEndTimeChanged = existingOrder.PublicationEnd != newPublicationEnd;
            existingOrder.PublicationEnd = newPublicationEnd;

            return publicationStartTimeChanged || publicationEndTimeChanged;
        }

        /// <summary>
        /// Applicable in the use case where the existing order got removed.
        /// Adds the booked non-feenix services from the existing order to the new Feenix order.
        /// Updates the timing of these services so they match the possible updated timing from Feenix.
        /// Output order will have status preliminary, so routing services can be ignored.
        /// </summary>
        /// <param name="existingOrder">Existing order that got removed.</param>
        /// <param name="newOrder">Order to which to add the non-feenix services.</param>
        /// <returns></returns>
        private void AddExistingNonFeenixServicesToFeenixOrder(Order existingOrder, Order newOrder)
        {
            // TODO: add support for backup services
            existingOrder.RemoveAutogenerateServices();

            var existingSourceService = existingOrder.MainSourceService;
            if (existingSourceService == null) return;

            var newSourceService = newOrder.MainSourceService;
            foreach (var service in existingSourceService.Children)
            {
                if (service.IntegrationType == IntegrationType.Feenix) continue;

                service.IsBooked = false;
                service.Start = newOrder.Start;
                service.End = newOrder.End;
                service.OrderReferences.Clear(); // remove the order ID of the existing Order
                if (service.ReservationInstance != null) service.UpdateOrderReferencesProperty(helpers);

                newSourceService.Children.Add(service);
            }
        }

        private void UpdateServicesToRecordOrTransmit(Order existingOrder, Order newOrder)
        {
            var existingSourceService = existingOrder.MainSourceService;
            var existingDestinationService = existingOrder.FeenixDestinationService;

            string existingSourceServiceName = String.IsNullOrEmpty(existingSourceService?.Name) ? String.Empty : existingSourceService.Name;
            string existingDestinationServiceName = String.IsNullOrEmpty(existingDestinationService?.Name) ? String.Empty : existingDestinationService.Name;

            Service newSourceService = newOrder.MainSourceService;
            Service newDestinationService = newOrder.FeenixDestinationService;

            string newSourceServiceName = newSourceService.Name;
            string newDestinationServiceName = newDestinationService?.Name;

            helpers.Log(nameof(FeenixIntegration), nameof(UpdateServicesToRecordOrTransmit), $"Existing source: {existingSourceServiceName}, existing destination: {existingDestinationServiceName}, new source: {newSourceService.Name}, new destination: {newDestinationService?.Name}");

            foreach (Service service in newOrder.AllServices)
            {
                UpdateServiceToRecordOrTransmit(newOrder, service, existingSourceServiceName, newSourceServiceName, existingDestinationServiceName, newDestinationServiceName);
            }
        }

        private void UpdateServiceToRecordOrTransmit(Order newOrder, Service newService, string existingSourceServiceName, string newSourceServiceName, string existingDestinationServiceName, string newDestinationServiceName)
        {
            if (newService.Definition.VirtualPlatform != VirtualPlatform.Recording && newService.Definition.VirtualPlatformServiceType != VirtualPlatformType.Transmission) return;

            if (String.Equals(newService.NameOfServiceToTransmitOrRecord, existingSourceServiceName) || !newOrder.AllServices.Exists(x => String.Equals(x.Name, newService.NameOfServiceToTransmitOrRecord)))
            {
                // If no service is present in the new order with the given name, select the source function to record or transmit.
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateServiceToRecordOrTransmit), $"Changing Name of Service to Transmit or Record on Service {newService.Name} from {newService.NameOfServiceToTransmitOrRecord} to {newSourceServiceName}");
                newService.NameOfServiceToTransmitOrRecord = newSourceServiceName;
            }
            else if (!String.IsNullOrEmpty(existingDestinationServiceName) && String.Equals(newService.NameOfServiceToTransmitOrRecord, existingDestinationServiceName))
            {
                string nameToSet = String.IsNullOrWhiteSpace(newDestinationServiceName) ? newSourceServiceName : newDestinationServiceName;
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateServiceToRecordOrTransmit), $"Changing Name of Service to Transmit or Record on Service {newService.Name} from {newService.NameOfServiceToTransmitOrRecord} to {nameToSet}");
                newService.NameOfServiceToTransmitOrRecord = nameToSet;
            }
            else
            {
                // Keep name of service to record or transmit
            }
        }

        private Service AddOrUpdateDestinationService(Order existingOrder, FeenixOrder feenixOrder)
        {
            if (existingOrder == null) throw new ArgumentNullException(nameof(existingOrder));
            if (feenixOrder == null) throw new ArgumentNullException(nameof(feenixOrder));

            var sourceService = existingOrder.MainSourceService;
            if (sourceService == null) throw new Skyline.DataMiner.DeveloperCommunityLibrary.YLE.Exceptions.ServiceNotFoundException(BackupType.None);

            var existingDestinationService = existingOrder.FeenixDestinationService;

            helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateDestinationService), $"Found existing feenix destination {existingDestinationService?.Name}");

            Service newDestinationService;
            bool isDestinationServiceRunning = existingDestinationService?.Status == YLE.Service.Status.ServiceRunning;
            bool updateAllowed = existingDestinationService == null || existingDestinationService.IntegrationIsMaster || existingDestinationService.IsDummy && !isDestinationServiceRunning;
            if (updateAllowed)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateDestinationService), $"Existing destination is {(existingDestinationService == null ? "null" : "not null")}, integration is {(existingDestinationService != null && existingDestinationService.IntegrationIsMaster ? "master" : "not master")} and source status is {existingDestinationService?.Status}, creating destination service");

                var destinationResource = GetDestinationResource(feenixOrder.RoutingOutput);
                newDestinationService = CreateDestinationService(feenixOrder, destinationResource, existingDestinationService); // Can be null
            }
            else
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateDestinationService), "Integration is not master or service is running, not updating destination service");

                newDestinationService = existingDestinationService;
            }

            return newDestinationService;
        }

        private bool ReinvigorateCanceledOrder(Order order)
        {
            if (order.Status != OrderStatus.Cancelled) return false;

            // Reinvigorate order
            helpers.Log(nameof(FeenixIntegration), nameof(ReinvigorateCanceledOrder), $"Reinvigorating existing canceled Feenix order");

            order.Status = OrderStatus.Preliminary;
            return true;
        }

        private bool AddOrUpdateOrderName(Order order, string name)
        {
            if (order == null) throw new ArgumentNullException(nameof(order));
            if (name == null) throw new ArgumentNullException(nameof(name));

            if (order.Name != name)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateOrderName), $"Changed order name from {order.Name} to {name}, update required");
                order.ManualName = name;
                return true;
            }

            helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateOrderName), $"No name change update required");
            return false;
        }

        private bool UpdateOrderTiming(Order order)
        {
            if (order == null) throw new ArgumentNullException(nameof(order));

            bool updateRequired = false;

            var earliestService = order.AllServices.Where(x => !x.IsSharedSource).OrderBy(s => s.Start).First();
            var lastService = order.AllServices.Where(x => !x.IsSharedSource).OrderByDescending(s => s.End).First();

            helpers.Log(nameof(FeenixIntegration), nameof(UpdateOrderTiming), $"EarliestService: {earliestService.Name}, VP: {earliestService.Definition?.VirtualPlatform}, Start: {earliestService.Start.ToString("O")}, End: {earliestService.End.ToString("O")}");
            helpers.Log(nameof(FeenixIntegration), nameof(UpdateOrderTiming), $"LastService: {lastService.Name}, VP: {lastService.Definition?.VirtualPlatform}, Start: {lastService.Start.ToString("O")}, End: {lastService.End.ToString("O")}");

            if (order.Start != earliestService.Start)
            {
                order.Start = earliestService.Start;
                updateRequired = true;

                helpers.Log(nameof(FeenixIntegration), nameof(UpdateOrderTiming), $"Changed order start time to {order.Start.ToString("O")} based on service {earliestService.Name}, update required");
            }

            if (order.End != lastService.End)
            {
                order.End = lastService.End;
                updateRequired = true;

                helpers.Log(nameof(FeenixIntegration), nameof(UpdateOrderTiming), $"Changed order end time to {order.End.ToString("O")} based on service {lastService.Name}, update required");
            }

            return updateRequired;
        }

        /// <summary>
        /// Handles any Event updates for the Order.
        /// </summary>
        /// <param name="order">Order for which it's event should be checked for updates.</param>
        /// <param name="feenixOrder">Information about the Feenix update.</param>
        /// <returns>True if a change was done to the Event or Order, else false.</returns>
        private bool UpdateEvent(Order order, FeenixOrder feenixOrder)
        {
            if (order.Event == null)
            {
                // New order
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateEvent), "Generating new event for Feenix Order");
                order.Event = DetermineFeenixEvent(feenixOrder, order);
                return true;
            }

            // Event != null
            if (!feenixOrder.HasValidCeitonProjectId)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateEvent), "Feenix does not specify a valid Ceiton ID, no event update required");
                return false; // No changes to order
            }

            // Has valid Ceiton Project ID
            if (String.Equals(order.Event.ProjectNumber, feenixOrder.CeitonProjectId))
            {
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateEvent), "Feenix Project ID matches Event Project Number");
                if (feenixOrder.HasValidCeitonProductId && !order.Event.ProductNumbers.Contains(feenixOrder.CeitonProductId))
                {
                    // Add Feenix Product ID to Event
                    helpers.Log(nameof(FeenixIntegration), nameof(UpdateEvent), $"Adding Ceiton Product ID {feenixOrder.CeitonProductId} to Event");
                    HashSet<string> productNumbers = new HashSet<string>(order.Event.ProductNumbers);
                    productNumbers.Add(feenixOrder.CeitonProductId);
                    order.Event.ProductNumbers = productNumbers;

                    // Update event
                    helpers.EventManager.AddOrUpdateEvent(order.Event);
                }

                return false; // Order is already linked to Ceiton Event
            }

            // Has valid Ceiton Project ID but does not match Event Project ID
            helpers.Log(nameof(FeenixIntegration), nameof(UpdateEvent), $"Generating new event for Feenix Order as the Project ID ({feenixOrder.CeitonProjectId}) of the existing Event ({order.Event.ProjectNumber}) does not match the updated value from Feenix");
            Event newEvent = DetermineFeenixEvent(feenixOrder, order);

            order.Event = newEvent;
            return true;
        }

        private bool AddOrUpdateIntegrationType(Order order)
        {
            if (order.IntegrationType != IntegrationType.Feenix)
            {
                order.IntegrationType = IntegrationType.Feenix;
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateIntegrationType), $"Changed order integration type to Feenix, update required");
                return true;
            }

            helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdateIntegrationType), $"No integration type update required");
            return false;
        }

        private bool AddOrUpdatePlasmaId(Order order, string plasmaId)
        {
            if (order == null) throw new ArgumentNullException(nameof(order));
            if (plasmaId == null) throw new ArgumentNullException(nameof(plasmaId));

            if (order.PlasmaId != plasmaId)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdatePlasmaId), $"Changed order plasma ID from {order.PlasmaId} to {plasmaId}, update required");
                order.PlasmaId = plasmaId;
                return true;
            }

            helpers.Log(nameof(FeenixIntegration), nameof(AddOrUpdatePlasmaId), $"No Plasma ID update required");
            return false;
        }

        private UpdatedService UpdateSourceService(Service oldSourceService, Service newSourceService)
        {
            if (oldSourceService == null) throw new ArgumentNullException(nameof(oldSourceService));
            if (newSourceService == null) throw new ArgumentNullException(nameof(newSourceService));

            UpdatedService updatedSourceService = new UpdatedService { Service = oldSourceService, UpdatePerformed = false };
            bool sourceServiceIsRunning = oldSourceService.Status == YLE.Service.Status.ServiceRunning;
            bool updateAllowed = oldSourceService.IntegrationIsMaster || oldSourceService.IsDummy && !sourceServiceIsRunning;
            if (updateAllowed)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateSourceService), $"Integration is {(oldSourceService.IntegrationIsMaster ? string.Empty : "not")} master, source is {(oldSourceService.IsDummy ? string.Empty : "not")} dummy, source service status is {oldSourceService.Status}, creating source service");
                updatedSourceService = UpdateService(oldSourceService, newSourceService, IgnoredItems.None);
            }
            else
            {
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateSourceService), $"Integration is {(oldSourceService.IntegrationIsMaster ? string.Empty : "not")} master, source is {(oldSourceService.IsDummy ? string.Empty : "not")} dummy, source service status is {oldSourceService.Status}, not updating source service");
            }

            return updatedSourceService;
        }

        /// <summary>
        /// Updates the existing Order with the new source and destination.
        /// </summary>
        /// <param name="existingOrder">Order to be updated.</param>
        /// <param name="newSourceService">New source service generated by the update from Feenix.</param>
        /// <param name="newDestinationService">New destination services generated by the update from Feenix.</param>
        private bool UpdateSourceAndDestinationInOrder(Order existingOrder, Service newSourceService, Service newDestinationService)
        {
            bool updateRequired = false;
            var existingSourceService = existingOrder.MainSourceService;

            if (existingSourceService == null)
            {
                // Should never be possible
                newSourceService.Children.Add(newDestinationService);
                existingOrder.Sources.Add(newSourceService);
                updateRequired = true;

                helpers.Log(nameof(FeenixIntegration), nameof(UpdateSourceAndDestinationInOrder), $"No existing main source service found, added new source service {newSourceService.Name} ({newSourceService.Id})");
            }
            else
            {
                bool sourceGotUpdated = UpdateSourceInOrder(existingOrder, newSourceService, existingSourceService);
                bool destinationGotUpdated = UpdateDestinationInOrder(existingOrder, newDestinationService, existingSourceService);
                updateRequired = sourceGotUpdated || destinationGotUpdated;
            }

            helpers.Log(nameof(FeenixIntegration), nameof(UpdateSourceAndDestinationInOrder), $"UpdateRequired: {updateRequired}");

            return updateRequired;
        }

        private bool UpdateSourceInOrder(Order existingOrder, Service newSourceService, Service existingSourceService)
        {
            bool updateRequired = false;

            bool reuseExistingSourceService = !existingSourceService.IsDummy && !existingSourceService.IntegrationIsMaster;
            if (!reuseExistingSourceService)
            {
                var updatedSourceService = UpdateService(existingSourceService, newSourceService, IgnoredItems.None);
                existingOrder.Sources.Remove(existingSourceService);
                existingOrder.Sources.Add(updatedSourceService.Service);

                updateRequired |= updatedSourceService.UpdatePerformed;
            }
            else
            {
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateSourceInOrder), $"Already manual updated existing source service may not be overwritten by a new Feenix source update | {nameof(reuseExistingSourceService)} = {reuseExistingSourceService}");
            }

            return updateRequired;
        }

        private bool UpdateDestinationInOrder(Order existingOrder, Service newDestinationService, Service existingSourceService)
        {
            bool updateRequired = false;

            var existingFeenixDestinationService = existingOrder.FeenixDestinationService;
            if (existingFeenixDestinationService == null)
            {
                if (newDestinationService != null)
                {
                    existingSourceService.Children.Add(newDestinationService);
                    updateRequired = true;

                    helpers.Log(nameof(FeenixIntegration), nameof(UpdateDestinationInOrder), $"Added {newDestinationService.Name} as destination to the order");
                }
            }
            else
            {
                var updatedDestinationService = UpdateService(existingFeenixDestinationService, newDestinationService, IgnoredItems.None);
                Service parentService = existingOrder.AllServices.FirstOrDefault(x => x.Children.Contains(existingFeenixDestinationService)) ?? throw new ServiceNotFoundException($"Unable to find parent of {existingFeenixDestinationService.Name}", true);
                parentService.Children.Remove(existingFeenixDestinationService);
                parentService.Children.Add(updatedDestinationService.Service);

                updateRequired |= updatedDestinationService.UpdatePerformed;
            }

            return updateRequired;
        }

        private bool UpdateServiceTiming(Order existingOrder, DateTime newStartTime, DateTime newEndTime)
        {
            var existingFeenixService = existingOrder.AllServices.First(x => x.IntegrationType == IntegrationType.Feenix);
            TimeSpan startTimeDifference = newStartTime - existingFeenixService.Start;

            var servicesToSkip = existingOrder.AllServices.Where(x => !ServiceRequiresTimingUpdate(x, newStartTime, newEndTime));
            var servicesWithOverlappingResources = GetServicesOccupyingSameResources(existingOrder.AllServices.Except(servicesToSkip));
            var distintServicesWithOverlappingResources = servicesWithOverlappingResources.SelectMany(x => x.Value).Distinct();

            bool timingChanged = false;
            foreach (var service in existingOrder.AllServices.Except(servicesToSkip).Except(distintServicesWithOverlappingResources))
            {
                Log(nameof(UpdateServiceTiming), $"Updating Service {service.Name} Start time from {service.Start.ToString("O")} to {newStartTime.ToString("O")} and end time of Service {service.Name} from {service.End.ToString("O")} to {newEndTime.ToString("O")}");

                service.Start = newStartTime;
                service.End = newEndTime;
                timingChanged = true;
            }

            Log(nameof(UpdateServiceTiming), $"Overlapping services: {String.Join("; ", servicesWithOverlappingResources.Select(x => $"{x.Key.Name}: {String.Join(", ", x.Value.Select(s => s.Name))}"))}");

            foreach (var kvp in servicesWithOverlappingResources)
            {
                LinkedList<Service> orderdedServices = new LinkedList<Service>(kvp.Value.OrderBy(x => x.Start));

                foreach (var serviceToShift in orderdedServices)
                {
                    DateTime shiftedStartTime = serviceToShift.Start + startTimeDifference;
                    DateTime shiftedEndTime = serviceToShift.End + startTimeDifference;

                    Log(nameof(UpdateServiceTiming), $"Updating Service {serviceToShift.Name} Start time from {serviceToShift.Start.ToString("O")} to {shiftedStartTime.ToString("O")} and end time of Service {serviceToShift.Name} from {serviceToShift.End.ToString("O")} to {shiftedEndTime.ToString("O")}");

                    serviceToShift.Start = shiftedStartTime;
                    serviceToShift.End = shiftedEndTime;
                }

                Log(nameof(UpdateServiceTiming), $"Updating Service {orderdedServices.First.Value.Name} Start time from {orderdedServices.First.Value.Start.ToString("O")} to {newStartTime.ToString("O")}");
                orderdedServices.First.Value.Start = newStartTime;

                Log(nameof(UpdateServiceTiming), $"Updating Service {orderdedServices.Last.Value.Name} End time of Service {orderdedServices.Last.Value.Name} from {orderdedServices.Last.Value.End.ToString("O")} to {newEndTime.ToString("O")}");
                orderdedServices.Last.Value.End = newEndTime;
            }

            return timingChanged;
        }

        private static bool ServiceRequiresTimingUpdate(Service service, DateTime newStartTime, DateTime newEndTime)
        {
            if (service.IsSharedSource) return false;
            if (service.End <= DateTime.Now) return false; // Don't update finished services
            if (service.Start.Equals(newStartTime) && service.End.Equals(newEndTime)) return false;
            return true;
        }

        private IReadOnlyDictionary<Resource, HashSet<Service>> GetServicesOccupyingSameResources(IEnumerable<Service> services)
        {
            Dictionary<Resource, HashSet<Service>> resourceCounts = new Dictionary<Resource, HashSet<Service>>();
            foreach (var service in services)
            {
                foreach (var function in service.Functions)
                {
                    Log(nameof(GetServicesOccupyingSameResources), $"{service.Name}.{function.Name} has resource {function.Resource?.Name ?? "None"}");

                    if (function.Resource == null) continue;

                    if (resourceCounts.ContainsKey(function.Resource))
                    {
                        resourceCounts[function.Resource].Add(service);
                    }
                    else
                    {
                        resourceCounts.Add(function.Resource, new HashSet<Service> { service });
                    }
                }
            }

            return resourceCounts.Where(x => x.Value.Count > x.Key.MaxConcurrency).ToDictionary(x => x.Key, x => x.Value);
        }

        /// <summary>
        /// Updates the status of the order.
        /// This does not update the order in SRM.
        /// </summary>
        /// <param name="order">Order to be updated.</param>
        /// <param name="criticalServiceChanges">Critical service changes will set the order to change requested state.</param>
        /// <returns>Boolean indicating if the Order was updated or not.</returns>
        private bool UpdateOrderStatus(Order order, bool criticalServiceChanges)
        {
            bool updateRequired;
            if (order.IsSaved)
            {
                // Only state in which the Order can be saved
                updateRequired = UpdateSavedOrderStatus(order);
            }
            else
            {
                updateRequired = UpdateBookedOrderStatus(order, criticalServiceChanges);
            }

            return updateRequired;
        }

        private bool UpdateSavedOrderStatus(Order order)
        {
            bool updateRequired = false;

            // Feenix Use Case 2: Set the status of the Order to Confirmed if the Resources are known or to Preliminary if any Resource is unknown.
            // We'll save the order (and set the status to planned) when we don't have enough information to completely configure the Services.
            if (IsFeenixOrderComplete(order))
            {
                order.Status = OrderStatus.Confirmed;
                updateRequired = true;

                helpers.Log(nameof(FeenixIntegration), nameof(UpdateOrderStatus), $"Order is saved and complete, setting status to confirmed, update required");
            }
            else
            {
                order.Status = order.MainSourceService?.Definition?.VirtualPlatformServiceName == VirtualPlatformName.Unknown ? OrderStatus.PlannedUnknownSource : OrderStatus.Preliminary;

                helpers.Log(nameof(FeenixIntegration), nameof(UpdateOrderStatus), $"Order is saved and incomplete, setting status to {order.Status}, no update required");
            }

            return updateRequired;
        }

        private bool UpdateBookedOrderStatus(Order order, bool criticalServiceChanges)
        {
            bool updateRequired = false;
            if (order.ShouldBeRunning)
            {
                // A running order should keep its running status regardless of what changes were made
                return false;
            }
            else if (order.Status == OrderStatus.Planned)
            {
                // Feenix orders should stay planned as long a it hasn't been touched by MCR operators
                // E.g. Non-MCR completes preliminary Feenix order by specifying source
                return false;
            }
            else if (criticalServiceChanges)
            {
                order.Status = OrderStatus.ChangeRequested;
                updateRequired = true;
            }
            else if (order.Status != OrderStatus.Confirmed)
            {
                order.Status = OrderStatus.Confirmed;
                updateRequired = true;
            }
            else
            {
                // No order status updates required
                helpers.Log(nameof(FeenixIntegration), nameof(UpdateBookedOrderStatus), $"Keeping existing order status: {order.Status}");
            }

            return updateRequired;
        }

        /// <summary>
        /// A Feenix Order is complete when it has a non-dummy Source,
        /// if the Source was created by Feenix it should be fully defined
        /// and when the order contains a Feenix Destination.
        /// </summary>
        /// <param name="order">Checks if the SRM order contains the required information to be booked as a Feenix Order.</param>
        /// <returns>True if the order contains the required information to be booked as a Feenix Order, else false.</returns>
        public static bool IsFeenixOrderComplete(Order order)
        {
            Service sourceService = order.MainSourceService;
            Service feenixDestinationService = order.FeenixDestinationService;

            if (sourceService.IsDummy) return false;
            if (feenixDestinationService == null) return false;

            return true;
        }

        /// <summary>
        /// Creates a new Reception Service object based on the information provided by Feenix and assigns the provided Resource to the last function in the Service.
        /// </summary>
        /// <param name="feenixOrder">Information provided through the Feenix integration.</param>
        /// <param name="resource">Resource to be assigned to the last function in the Service.</param>
        /// <param name="existingSourceService"></param>
        /// <returns>Reception Service object.</returns>
        private Service CreateSourceService(FeenixOrder feenixOrder, FunctionResource resource, Service existingSourceService = null)
        {
            if (resource == null)
            {
                // If no resource was found, use a default service.
                helpers.Log(nameof(FeenixIntegration), nameof(CreateSourceService), $"Resource is null, created dummy source service");
                return CreateDummySourceService(feenixOrder);
            }

            // Get all resource pools for the resource
            var resourcePools = resource.PoolGUIDs
                .Select(p => helpers.ResourceManager.GetResourcePools(new ResourcePool { GUID = p }).FirstOrDefault())
                .Where(p => p != null)
                .Select(p => p.Name)
                .ToList();
            if (!resourcePools.Any())
            {
                // If resource is not part of any resource pool, use a default service.
                helpers.Log(nameof(FeenixIntegration), nameof(CreateSourceService), $"Resource is not part of any resource pool, created dummy source service");
                return CreateDummySourceService(feenixOrder);
            }

            // Find Service Definitions that have a function that requires a resource from the resource pools
            var serviceDefinitions = ReceptionServiceDefinitions.Where(s => s.FunctionDefinitions.Any(f => resourcePools.Contains(f.ResourcePool))).ToList();

            // Select one of the service definitions
            // If the Fixed Servie service definition is eligible then this one should have priority
            var serviceDefinition = serviceDefinitions.FirstOrDefault(s => s.VirtualPlatform == VirtualPlatform.ReceptionFixedService) ?? serviceDefinitions.FirstOrDefault();
            if (serviceDefinition == null)
            {
                // If no service definition was found, use a default service.
                helpers.Log(nameof(FeenixIntegration), nameof(CreateSourceService), $"No service definition found, created dummy source service");
                return CreateDummySourceService(feenixOrder);
            }

            helpers.Log(nameof(FeenixIntegration), nameof(CreateSourceService), $"Found service definition {serviceDefinition.Name} that contains a function where resource {resource.Name} can be assigned to");

            if (serviceDefinition.VirtualPlatform == VirtualPlatform.ReceptionFixedService)
            {
                // In case of Fixed Service, swap the decoding resource for the applicable Fixed Service source
                // This is needed to make sure the correct resource(s) are selected
                resource = GetFixedServiceResourceLinkedToIrd(serviceDefinition, resource);
                if (resource == null)
                {
                    // If no resource was found, use a default service.
                    helpers.Log(nameof(FeenixIntegration), nameof(CreateSourceService), $"Fixed service resource is null, created dummy source service");
                    return CreateDummySourceService(feenixOrder);
                }
            }

            var functions = GetUpdatedFunctions(serviceDefinition, resource, existingSourceService?.Functions);

            // Create Source Service
            var service = new DisplayedService
            {
                Start = feenixOrder.Start,
                End = feenixOrder.End,
                IntegrationType = IntegrationType.Feenix,
                IntegrationIsMaster = true,
                BackupType = BackupType.None,
                Comments = "Automatically created by Feenix integration",
                Functions = functions,
                Definition = serviceDefinition,
                RequiresRouting = true
            };

            helpers.Log(nameof(FeenixIntegration), nameof(CreateSourceService), $"Created source service {JsonConvert.SerializeObject(service.GetConfiguration())}");

            return service;
        }

        /// <summary>
        /// Generates a new Dummy Reception service based on the information received from Feenix.
        /// </summary>
        /// <param name="order">Contains information on the Feenix Order.</param>
        /// <returns>Newly generated dummy service.</returns>
        private Service CreateDummySourceService(FeenixOrder order)
        {
            var service = Service.GenerateDummyReception(helpers, order.Start, order.End);

            // Integration Type is set to "None" to make sure the user can create a "custom" source
            service.IntegrationType = IntegrationType.None;
            //service.Comments = "Automatically created by Feenix Integration";

            return service;
        }

        /// <summary>
        /// Generates a new Destination service based on the information received from Feenix and the provided resource.
        /// </summary>
        /// <param name="feenixOrder">Contains information on the Feenix Order.</param>
        /// <param name="resource">Resource to be assigned to the destination function in the service.</param>
        /// <param name="existingDestinationService"></param>
        /// <returns>Newly generated destination service.</returns>
        private Service CreateDestinationService(FeenixOrder feenixOrder, FunctionResource resource, Service existingDestinationService = null)
        {
            if (resource == null) return null;
            var serviceDefinition = AreenaDestinationServiceDefinition;

            var functions = GetUpdatedFunctions(serviceDefinition, resource, existingDestinationService?.Functions);

            // Create Destination Service
            var destinationService = new DisplayedService
            {
                Start = feenixOrder.Start,
                End = feenixOrder.End,
                IntegrationType = IntegrationType.Feenix,
                IntegrationIsMaster = true,
                BackupType = BackupType.None,
                Comments = "Automatically created by Feenix integration",
                Functions = functions,
                Definition = serviceDefinition,
                RequiresRouting = true
            };

            helpers.Log(nameof(FeenixIntegration), nameof(CreateDestinationService), $"Created destination service {JsonConvert.SerializeObject(destinationService.GetConfiguration())}");

            // Set Audio Channels will be done manually
            // Set Video Format will be done manually

            return destinationService;
        }

        /// <summary>
        /// Creates new functions based on the provided service definition.
        /// The function to which the resource can be assigned will be configured to accept the resource.
        /// The other functions will be initialized with default values for their profile parameters.
        /// </summary>
        /// <param name="serviceDefinition">Service definition for which the functions are to be generated.</param>
        /// <param name="resource">Resource that will be assigned to a function in the service definition.</param>
        /// <param name="functionsToCopy"></param>
        /// <returns>A list of functions generated for the provided service definition.</returns>
        private List<Function> GetUpdatedFunctions(ServiceDefinition serviceDefinition, FunctionResource resource = null, List<Function> functionsToCopy = null)
        {
            var updatedFunctions = new List<Function>();
            foreach (var functionDefinition in serviceDefinition.FunctionDefinitions)
            {
                var node = serviceDefinition.Diagram.Nodes.FirstOrDefault(x => x.Configuration.FunctionID == functionDefinition.Id);

                helpers.Log(nameof(FeenixIntegration), nameof(GetUpdatedFunctions), $"Handling function definition {functionDefinition.Name} (label {functionDefinition.Label})", serviceDefinition.Name);

                Function function;
                var existingFunction = functionsToCopy != null ? functionsToCopy.SingleOrDefault(f => f.Id == functionDefinition.Id && f.Definition.Label == functionDefinition.Label) : null;
                if (existingFunction != null)
                {
                    // try to reuse existing function to not lose profile parameter values
                    function = existingFunction.Clone() as Function;
                    helpers.Log(nameof(FeenixIntegration), nameof(GetUpdatedFunctions), $"Copied existing function {JsonConvert.SerializeObject(function.Configuration)}", serviceDefinition.Name);
                }
                else
                {
                    var defaultProfileParameters = GetDefaultProfileParameters(functionDefinition);
                    function = new DisplayedFunction(helpers, node, functionDefinition);
                    function.Parameters = defaultProfileParameters;

                    helpers.Log(nameof(FeenixIntegration), nameof(GetUpdatedFunctions), $"Created new function {JsonConvert.SerializeObject(function.Configuration)}", serviceDefinition.Name);
                }

                // Take System function definitions into account
                if (resource != null && (functionDefinition.Id.Equals(resource.FunctionGUID) || functionDefinition.Children.Contains(resource.FunctionGUID)))
                {
                    function.Resource = resource;
                    function.EnforceSelectedResource = true;

                    MatchCapabilityValuesToResource(function);

                    helpers.Log(nameof(FeenixIntegration), nameof(GetUpdatedFunctions), $"Matched capabilities to allow resource {resource.Name}: {JsonConvert.SerializeObject(function.Configuration)}", serviceDefinition.Name);
                }

                updatedFunctions.Add(function);
            }

            // TODO remove when DVEO resources are no longer used in prod or when successfully tested that this part is redundant
            // Hardcoded part for IP RTMP resources as urgent hotfix for production.
            if (serviceDefinition.Id == ServiceDefinitionGuids.IpReceptionRtmp)
            {
                var ipDecodingFunction = updatedFunctions.SingleOrDefault(f => f.Id == FunctionGuids.IpDecoding) ?? throw new FunctionNotFoundException(FunctionGuids.IpDecoding);
                if (ipDecodingFunction.ResourceName.Contains("DVEO"))
                {
                    var ipDecodingOutputFunction = updatedFunctions.SingleOrDefault(f => f.Id == FunctionGuids.IpDecodingOutput) ?? throw new FunctionNotFoundException(FunctionGuids.IpDecodingOutput);

                    var dummyProfileParameter = ipDecodingOutputFunction.Parameters.SingleOrDefault(p => p.Id == ProfileParameterGuids._Dummy) ?? throw new ProfileParameterNotFoundException(ProfileParameterGuids._Dummy);
                    dummyProfileParameter.Value = true.ToString();
                }
            }

            return updatedFunctions;
        }

        private static void MatchCapabilityValuesToResource(Function function)
        {
            foreach (var profileParameter in function.Parameters)
            {
                var capability = function.Resource.Capabilities.FirstOrDefault(x => x.CapabilityProfileID.Equals(profileParameter.Id));
                if (capability != null && !capability.Value.Discreets.Contains(profileParameter.Value))
                {
                    profileParameter.Value = capability.Value.Discreets[0];
                }
            }
        }

        /// <summary>
        /// Returns a Resource that can be assigned to the last Function of the Source Function in order to match the Matrix Input SDI resource received through Feenix.
        /// </summary>
        /// <param name="routingInputResourceName">Name of the Source as received from the Feenix element.</param>
        /// <returns>Resource that can be assigned to the last Function of the Source Service.</returns>
        private FunctionResource GetSourceResource(string routingInputResourceName)
        {
            // Find a Matrix Input SDI resource that has the FeenixSource capability set to true and where its name or custom name property matches the provided source name
            if (feenixSourceParameter == null) return null;

            // Get Matrix Input SDI Resource Pool
            var matrixInputSdiResourcePool = helpers.ResourceManager.GetResourcePoolByName(SrmConfiguration.MatrixInputSdiResourcePool);
            if (matrixInputSdiResourcePool == null) return null;

            // Find a Resource in the Matrix Input SDI Resource Pool that has the FeenixSource property set to true and whose name or custom name property matches the RoutingInput Source from Feenix
            var feenixSources = helpers.ResourceManager.GetFeenixSourceResources(matrixInputSdiResourcePool.GUID, feenixSourceParameter.Id);
            var routingInputResource = feenixSources.FirstOrDefault(x => x.Name.Equals(routingInputResourceName) || x.Properties.Any(p => p.Name.Equals("Custom Name") && p.Value.Equals(routingInputResourceName))) as FunctionResource;

            helpers.Log(nameof(FeenixIntegration), nameof(GetSourceResource), $"Found routing resource {routingInputResource?.Name ?? "'none'"} with custom name property equal to '{routingInputResourceName}'");
            if (routingInputResource == null) return null;

            // Get Name of the Connected Resource
            var resourceInputConnectionsSdiCapability = routingInputResource.Capabilities.FirstOrDefault(c => c.CapabilityProfileID.Equals(resourceInputConnectionsSdiParameter.Id));
            if (resourceInputConnectionsSdiCapability == null) return null;

            var inputResourceName = resourceInputConnectionsSdiCapability.Value.Discreets.FirstOrDefault(r => r.Contains("Decoding")) ?? resourceInputConnectionsSdiCapability.Value.Discreets.FirstOrDefault();

            helpers.Log(nameof(FeenixIntegration), nameof(GetSourceResource), $"Found connected resource name {inputResourceName} among capability values {string.Join(",", resourceInputConnectionsSdiCapability.Value.Discreets)} on {routingInputResource.Name}");
            if (inputResourceName == null) return null;

            var inputResource = helpers.ResourceManager.GetResourcesByName(inputResourceName).FirstOrDefault() as FunctionResource;

            helpers.Log(nameof(FeenixIntegration), nameof(GetSourceResource), $"Found connected resource {inputResource?.Name}");

            return inputResource;
        }

        /// <summary>
        /// Returns the Fixed Service resource linked to the provided IRD.
        /// </summary>
        /// <param name="serviceDefinition"></param>
        /// <param name="decodingResource">The decoding resource.</param>
        /// <returns>The Fixed Service Resource</returns>
        private FunctionResource GetFixedServiceResourceLinkedToIrd(ServiceDefinition serviceDefinition, FunctionResource decodingResource)
        {
            var fixedServiceFunctionDefinition = serviceDefinition.FunctionDefinitions.FirstOrDefault(f => f.Name == "Fixed Service");
            if (fixedServiceFunctionDefinition == null) return null;

            var resourcePool = helpers.ResourceManager.GetResourcePools(new ResourcePool { Name = fixedServiceFunctionDefinition.ResourcePool }).FirstOrDefault();
            if (resourcePool == null) return null;

            var fixedServiceResources = helpers.ResourceManager.GetResources(ResourceExposers.PoolGUIDs.Contains(resourcePool.GUID));
            if (fixedServiceResources == null || !fixedServiceResources.Any()) return null;

            var irdName = decodingResource.Name.Split('.')[0];
            foreach (var fixedServiceResource in fixedServiceResources)
            {
                var linkedIrdProperty = fixedServiceResource.Properties.FirstOrDefault(p => p.Name == "LinkedIRD");
                if (linkedIrdProperty == null) continue;

                if (linkedIrdProperty.Value == irdName) return fixedServiceResource as FunctionResource;
            }

            return null;
        }

        /// <summary>
        /// Tries to find a resource from the Destination.Areena Destination Resource pool that matches the destination retrieved from Feenix.
        /// Ex.: Feenix Destination: NET01.
        /// Matching Resources: NET01, NET 01, NET01.Destination, NET 01.wathever.
        /// </summary>
        /// <param name="destinationName">Name of the destination resource as retrieved from Feenix.</param>
        /// <returns>Destination resource if a matching resource was found, else null.</returns>
        private FunctionResource GetDestinationResource(string destinationName)
        {
            // Check the destination resource pool for a resource that matches the provided resource name
            var resourcePool = helpers.ResourceManager.GetResourcePools(new Skyline.DataMiner.Net.Messages.ResourcePool { Name = SrmConfiguration.AreenaDestinationResourcePool }).FirstOrDefault();
            if (resourcePool == null)
            {
                helpers.Log(nameof(FeenixIntegration), nameof(GetDestinationResource), "GetDestinationResource|Unable to retrieve Resource Pool with Name : " + SrmConfiguration.AreenaDestinationResourcePool);
                return null;
            }

            string cleanedDestinationName = destinationName.Replace(" ", String.Empty).ToUpper();
            return helpers.ResourceManager.GetResources(ResourceExposers.PoolGUIDs.Contains(resourcePool.ID)).FirstOrDefault(x => x.Name.Replace(" ", String.Empty).ToUpper().StartsWith(cleanedDestinationName)) as FunctionResource;
        }
    }
}